<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Online - Vista del Dealer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="/css/dealer.css">
</head>

<body>
    <!-- HEADER -->
    <header class="top-bar">
        <div class="left-group">
            <button class="exit-btn" onclick="exitRoom()">
                <i class="fas fa-door-open"></i> EXIT ROOM
            </button>
            <div class="invite-section">
                <span id="roomCodeText">CÃ³digo: </span>
                <button id="copyBtn">COPY</button>
            </div>
        </div>
        <div class="dealer-title">DEALER VIEW</div>
        <button class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </button>
        <nav class="mobile-menu" id="mobileMenu">
            <button class="how-to-play">ðŸ”Š HOW TO PLAY</button>
            <button class="exit-btn" onclick="exitRoom()">EXIT</button>
            <button onclick="copyRoomCode()">COPY INVITE</button>
        </nav>
        <button class="how-to-play desktop-only">ðŸ”Š HOW TO PLAY</button>
    </header>

    <!-- SIDEBAR -->
    <div class="sidebar">
        <div class="online-status">
            <div class="status-icon"></div>
            <span class="user-icon">ðŸ‘¥</span>
            <h2 id="contador">0</h2>
        </div>
        
        <!-- PANEL DE CONTROL DEL DEALER -->
        <div class="dealer-controls">
            <h3>Control del Juego</h3>
            
            <!-- Estado actual -->
            <div class="game-status">
                <div class="status-item">
                    <span>Estado:</span>
                    <span id="gameStateDisplay">Esperando</span>
                </div>
                <div class="status-item">
                    <span>Jugadores:</span>
                    <span id="playersCount">0</span>
                </div>
                <div class="status-item">
                    <span>Confirmados:</span>
                    <span id="confirmedCount">0/0</span>
                </div>
            </div>

            <!-- Botones de control -->
            <div class="control-buttons">
                <button id="startBettingBtn">
                    <i class="fas fa-play"></i> INICIAR APUESTAS
                </button>
                
                <button id="dealCardsBtn" disabled>
                    <i class="fas fa-layer-group"></i> REPARTIR CARTAS
                </button>
                
                <button id="resetGameBtn">
                    <i class="fas fa-redo"></i> REINICIAR
                </button>
            </div>

            <!-- Timer de apuestas -->
            <div class="betting-timer" id="bettingTimer" style="display: none;">
                <div>Tiempo restante:</div>
                <div class="timer-display" id="timerDisplay">30s</div>
                <div class="timer-bar">
                    <div class="timer-progress" id="timerProgress"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ÃREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- ÃREA DE JUGADORES -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>
        
        <!-- SVG DECORATIVO -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <path id="curve-top" d="M 150 150 Q 500 50 850 150" />
                    <path id="curve-bottom" d="M 150 200 Q 500 100 850 200" />
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>
                <path d="M 150 250 Q 500 150 850 250" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56" text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK PAY 3 TO 2
                    </textPath>
                </text>
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36" text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 17 AND DRAW TO 16
                    </textPath>
                </text>
            </svg>
        </div>
        
        <!-- ÃREA DEL DEALER -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>

            <!-- Las cartas que el dealer se reparte a sÃ­ mismo -->
            <div class="dealer-hand" id="dealerCards">
                <!-- Las cartas del dealer aparecerÃ¡n aquÃ­ cuando se repartan -->
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>

        // Variables globales
const socket = io();
let roomCode = '';
let gameState = 'waiting';
let playersList = [];
let bettingTimer = null;

// InicializaciÃ³n
document.addEventListener('DOMContentLoaded', () => {
    console.log('ðŸŽ® Iniciando vista del dealer...');
    
    // Extraer cÃ³digo de la URL
    const params = new URLSearchParams(window.location.search);
    roomCode = params.get('codigo');
    
    console.log('ðŸ“ CÃ³digo de sala detectado:', roomCode);

    if (roomCode) {
        setupRoomCode();
        joinRoomAsDealer();
    } else {
        showNotification('No se encontrÃ³ cÃ³digo de sala', 'error');
        return;
    }

    setupEventListeners();
    setupSocketEvents();
});

// Configurar cÃ³digo de sala
function setupRoomCode() {
    const roomCodeText = document.getElementById('roomCodeText');
    const copyBtn = document.getElementById('copyBtn');

    roomCodeText.textContent = `CÃ³digo: ${roomCode}`;
    
    copyBtn.onclick = copyRoomCode;
}

// Unirse como dealer
function joinRoomAsDealer() {
    console.log('ðŸŽ¯ UniÃ©ndose a la sala como dealer...');
    // Emitir sin playerName para identificarse como dealer
    socket.emit('joinRoom', roomCode);
}

// Configurar event listeners
function setupEventListeners() {
    // MenÃº hamburguesa
    const menuToggle = document.getElementById('menuToggle');
    const mobileMenu = document.getElementById('mobileMenu');

    if (menuToggle && mobileMenu) {
        menuToggle.addEventListener('click', () => {
            mobileMenu.classList.toggle('active');
        });
    }

    // Botones de control
    document.getElementById('startBettingBtn').addEventListener('click', startBetting);
    document.getElementById('dealCardsBtn').addEventListener('click', dealCards);
    document.getElementById('resetGameBtn').addEventListener('click', resetGame);
}

// Configurar eventos de Socket.IO
function setupSocketEvents() {
    console.log('ðŸ“¡ Configurando eventos de Socket.IO...');

    // ConexiÃ³n establecida
    socket.on('connect', () => {
        console.log('âœ… Conectado al servidor con ID:', socket.id);
        showNotification('Conectado al servidor', 'success');
    });

    // Lista de jugadores actualizada
    socket.on('updatePlayerList', (players) => {
        console.log('ðŸ‘¥ Lista de jugadores actualizada:', players);
        playersList = players;
        renderPlayers(players);
        updateGameStatus();
    });

    // Estado del juego actualizado
    socket.on('gameStateUpdate', (data) => {
        console.log('ðŸŽ® Estado del juego actualizado:', data);
        gameState = data.state;
        updateGameStateDisplay();
        updateControlButtons();
    });

    // PerÃ­odo de apuestas iniciado
    socket.on('bettingStarted', (data) => {
        console.log('ðŸŽ² PerÃ­odo de apuestas iniciado:', data);
        showNotification('Â¡PerÃ­odo de apuestas iniciado!', 'info');
        startBettingTimer(data.duration);
        updateControlButtons();
    });

    // Apuestas cerradas
    socket.on('bettingClosed', () => {
        console.log('â° PerÃ­odo de apuestas cerrado');
        showNotification('PerÃ­odo de apuestas cerrado', 'warning');
        stopBettingTimer();
        updateControlButtons();
    });

    // Jugador confirmÃ³ apuesta
    socket.on('playerBetConfirmed', (data) => {
        console.log('âœ… Jugador confirmÃ³ apuesta:', data);
        showNotification(`${data.playerName} confirmÃ³ $${data.bet}`, 'success');
        updateGameStatus();
        
        // Verificar si todos confirmaron
        const allConfirmed = playersList.every(p => p.betConfirmed);
        if (allConfirmed && playersList.length > 0) {
            showNotification('Â¡Todos confirmaron! Listo para repartir cartas', 'success');
        }
    });

    // ActualizaciÃ³n de turno
    socket.on('turnUpdate', (data) => {
        console.log(`[TURN] Turno de: ${data.playerName}`);
        showNotification(`Turno de: ${data.playerName}`, 'info');
        highlightCurrentPlayer(data.playerId);
    });

    // Un jugador pide una carta (Hit)
    socket.on('playerCardUpdate', (data) => {
        console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);
        
        const deckElement = document.querySelector('.deck-pile');
        if (!deckElement) return;
        const deckRect = deckElement.getBoundingClientRect();

        const dealInfo = {
            target: 'player',
            id: data.playerId,
            card: data.newCard
        };
        dealOneCard(dealInfo, deckRect);
    });

    // Errores
    socket.on('error', (data) => {
        console.error('âŒ Error del servidor:', data);
        showNotification('Error: ' + data.message, 'error');
    });

    // DesconexiÃ³n
    socket.on('disconnect', () => {
        console.log('âŒ Desconectado del servidor');
        showNotification('Desconectado del servidor', 'error');
    });

    // Juego reiniciado
    socket.on('gameReset', () => {
        console.log('ðŸ”„ Juego reiniciado por el servidor.');
        showNotification('El juego ha sido reiniciado.', 'info');
        // Limpiar manos y highlights
        document.getElementById('dealerCards').innerHTML = '';
        document.querySelectorAll('.player-cards-hand').forEach(hand => hand.innerHTML = '');
        document.querySelectorAll('.player-position').forEach(div => {
            div.classList.remove('current-turn');
        });
        stopBettingTimer();
    });

    // Eventos adicionales que podrÃ­an estar faltando
    socket.on('reconnect', () => {
        console.log('ðŸ”„ Reconectado al servidor');
        showNotification('Reconectado', 'success');
        // Volver a unirse a la sala
        if (roomCode) {
            socket.emit('joinRoom', roomCode);
        }
    });
}

// === FUNCIONES DE RENDERIZADO ===

function renderPlayers(players) {
    const playerCardsContainer = document.getElementById('playerCards');
    
    if (players.length === 0) {
        playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
        return;
    }

    playerCardsContainer.innerHTML = '';

    players.forEach((player, index) => {
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-position';
        playerDiv.dataset.playerId = player.id;

        let betDisplay = '';
        let floatingBetHtml = '';

        if (player.betConfirmed && player.bet > 0) {
            floatingBetHtml = `<div class="confirmed-bet-floater">$${player.bet}</div>`;
            betDisplay = `
                <div class="bet-confirmed-icon">
                    <i class="fas fa-check-circle"></i> 
                    <span>Confirmado</span>
                </div>`;
        } else if (player.bet > 0) {
            betDisplay = `<div class="bet-pending">$${player.bet} (Esperando)</div>`;
        } else {
            betDisplay = `<div class="no-bet">Sin apuesta</div>`;
        }

        playerDiv.innerHTML = `
            <div class="player-header">
                <div class="player-name-display">${player.name}</div>
                <div class="player-balance">$${player.balance || 100}</div>
            </div>
            <div class="player-cards-hand">
                <div class="card-slot">Esperando cartas...</div>
            </div>
            <div class="player-bet">${betDisplay}</div>
            ${floatingBetHtml}`;

        playerCardsContainer.appendChild(playerDiv);
    });
}

// === FUNCIONES DE CONTROL ===

function highlightCurrentPlayer(playerId) {
    // Remover highlight de todos los jugadores primero
    document.querySelectorAll('.player-position').forEach(div => {
        div.classList.remove('current-turn');
    });

    // Agregar highlight al jugador actual
    const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
    if (playerDiv) {
        playerDiv.classList.add('current-turn');
    }
}

function updateGameStatus() {
    const playersCount = playersList.length;
    const confirmedCount = playersList.filter(p => p.betConfirmed).length;

    document.getElementById('contador').textContent = playersCount;
    document.getElementById('playersCount').textContent = playersCount;
    document.getElementById('confirmedCount').textContent = `${confirmedCount}/${playersCount}`;

    updateControlButtons();
}

function updateGameStateDisplay() {
    const display = document.getElementById('gameStateDisplay');
    display.className = `game-state-${gameState}`;
    
    const stateNames = {
        waiting: 'Esperando',
        betting: 'Apostando',
        playing: 'Jugando',
        finished: 'Finalizado'
    };
    
    display.textContent = stateNames[gameState] || gameState;
}

function updateControlButtons() {
    const startBettingBtn = document.getElementById('startBettingBtn');
    const dealCardsBtn = document.getElementById('dealCardsBtn');
    
    console.log(`Actualizando botones - Estado: ${gameState}, Jugadores: ${playersList.length}`);
    
    // BotÃ³n iniciar apuestas
    if (gameState === 'waiting' && playersList.length > 0) {
        startBettingBtn.disabled = false;
        startBettingBtn.innerHTML = '<i class="fas fa-play"></i> INICIAR APUESTAS';
        startBettingBtn.style.opacity = '1';
    } else if (gameState === 'betting') {
        startBettingBtn.disabled = true;
        startBettingBtn.innerHTML = '<i class="fas fa-clock"></i> APOSTANDO...';
        startBettingBtn.style.opacity = '0.6';
    } else {
        startBettingBtn.disabled = true;
        startBettingBtn.innerHTML = '<i class="fas fa-play"></i> INICIAR APUESTAS';
        startBettingBtn.style.opacity = '0.6';
    }
    
    // BotÃ³n repartir cartas
    const allConfirmed = playersList.length > 0 && playersList.every(p => p.betConfirmed);
    
    if (gameState === 'playing' && allConfirmed) {
        dealCardsBtn.disabled = false;
        dealCardsBtn.style.opacity = '1';
    } else {
        dealCardsBtn.disabled = true;
        dealCardsBtn.style.opacity = '0.6';
    }
}

// === FUNCIONES DE TIMER ===

function startBettingTimer(duration) {
    const timerElement = document.getElementById('bettingTimer');
    const displayElement = document.getElementById('timerDisplay');
    const progressElement = document.getElementById('timerProgress');
    
    timerElement.style.display = 'block';
    let timeLeft = duration;
    
    // ActualizaciÃ³n inicial
    const seconds = Math.ceil(timeLeft / 1000);
    displayElement.textContent = `${seconds}s`;
    progressElement.style.width = '100%';
    
    bettingTimer = setInterval(() => {
        timeLeft -= 1000;
        
        const seconds = Math.ceil(timeLeft / 1000);
        displayElement.textContent = `${seconds}s`;
        
        const progressPercent = Math.max(0, (timeLeft / duration) * 100);
        progressElement.style.width = `${progressPercent}%`;
        
        // Cambiar color cuando quedan pocos segundos
        if (seconds <= 10) {
            displayElement.style.color = '#ff4757';
            progressElement.style.background = 'linear-gradient(90deg, #ff4757, #ff6b6b)';
        }
        
        if (timeLeft <= 0) {
            stopBettingTimer();
        }
    }, 1000);
}

function stopBettingTimer() {
    if (bettingTimer) {
        clearInterval(bettingTimer);
        bettingTimer = null;
    }
    
    const timerElement = document.getElementById('bettingTimer');
    const displayElement = document.getElementById('timerDisplay');
    const progressElement = document.getElementById('timerProgress');
    
    timerElement.style.display = 'none';
    
    // Resetear estilos
    displayElement.style.color = '#ff6b6b';
    progressElement.style.background = 'linear-gradient(90deg, #ff6b6b, #ffa500)';
}

// === FUNCIONES DE CONTROL DEL JUEGO ===

function startBetting() {
    console.log('ðŸŽ¯ Iniciando perÃ­odo de apuestas...');
    
    if (playersList.length === 0) {
        showNotification('No hay jugadores en la sala', 'warning');
        return;
    }
    
    if (gameState !== 'waiting') {
        showNotification('No se puede iniciar apuestas en este momento', 'warning');
        return;
    }
    
    const duration = 30000; // 30 segundos
    console.log('ðŸ“¡ Emitiendo evento startBetting con duraciÃ³n:', duration);
    
    // Deshabilitar botÃ³n inmediatamente para evitar mÃºltiples clics
    const startBettingBtn = document.getElementById('startBettingBtn');
    startBettingBtn.disabled = true;
    startBettingBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> INICIANDO...';
    
    socket.emit('startBetting', duration);
    
    // Feedback visual inmediato
    showNotification('Iniciando perÃ­odo de apuestas...', 'info');
}

function dealCards() {
    console.log('ðŸŽ° Repartiendo cartas...');
    
    const allConfirmed = playersList.every(p => p.betConfirmed);
    if (!allConfirmed || playersList.length === 0) {
        showNotification('No todos los jugadores han confirmado sus apuestas', 'warning');
        return;
    }
    
    // Deshabilitar botÃ³n para evitar clics mÃºltiples
    document.getElementById('dealCardsBtn').disabled = true;
    
    // Emitir evento al servidor para que reparta las cartas
    socket.emit('dealCards');
}

function resetGame() {
    if (confirm('Â¿Seguro que quieres reiniciar el juego? Esto limpiarÃ¡ todas las apuestas.')) {
        console.log('ðŸ”„ Reiniciando juego...');
        
        socket.emit('resetGame');
        showNotification('Reiniciando juego...', 'info');
        
        // Limpiar timer si estÃ¡ activo
        stopBettingTimer();
        
        // Resetear estado local
        gameState = 'waiting';
        updateGameStateDisplay();
        updateControlButtons();
    }
}

// === LÃ“GICA DE ANIMACIÃ“N DE CARTAS ===

socket.on('cardsDealt', (data) => {
    console.log('ðŸƒ Recibiendo cartas del servidor:', data);
    
    // Limpiar manos actuales antes de repartir
    document.getElementById('dealerCards').innerHTML = '';
    document.querySelectorAll('.player-cards-hand').forEach(hand => {
        hand.innerHTML = '';
    });

        // Aunque el dealer conoce su mano completa (data.dealer), para la animaciÃ³n
    // inicial, debemos mostrar la segunda carta como oculta, igual que los jugadores.
    // La mano real se guarda en el servidor.
    const dealerHandForDisplay = [
        data.dealer[0],  // La primera carta, visible
        { hidden: true } // La segunda carta, la mostramos oculta
    ];
    animateDealing(data.players, dealerHandForDisplay);
});

function createCardElement(card) {
    const cardDiv = document.createElement('div');
    
    if (card.hidden) {
        cardDiv.className = 'card card-back';
        return cardDiv;
    }

    // Usar la imagen de la carta como fondo
    cardDiv.className = 'card';
    cardDiv.style.backgroundImage = `url('/${card.src}')`;
    // Opcional: puedes dejar el texto superpuesto si tu CSS lo permite
    return cardDiv;
}

async function animateDealing(players, dealerHand) {
    const deckElement = document.querySelector('.deck-pile');
    if (!deckElement) return;

    const deckRect = deckElement.getBoundingClientRect();
    const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

    const dealSequence = [];

    // Ronda 1: Jugadores -> Dealer
    playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] }));
    dealSequence.push({ target: 'dealer', card: dealerHand[0] });

    // Ronda 2: Jugadores -> Dealer
    playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] }));
    dealSequence.push({ target: 'dealer', card: dealerHand[1] });

    for (const deal of dealSequence) {
        await dealOneCard(deal, deckRect);
    }
    // Una vez repartidas todas las cartas, aplicamos el efecto abanico
    applyFanEffect();
}

function dealOneCard(deal, deckRect) {
    return new Promise(resolve => {
        let targetHandElement;
        if (deal.target === 'player') {
            targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
        } else {
            targetHandElement = document.getElementById('dealerCards');
        }

        if (!targetHandElement) {
            console.warn(`No se encontrÃ³ el contenedor de mano para ${deal.target} ${deal.id || ''}`);
            return resolve();
        }

        const cardElement = createCardElement(deal.card);
        cardElement.classList.add('dealing-animation');
        cardElement.style.left = `${deckRect.left}px`;
        cardElement.style.top = `${deckRect.top}px`;

        document.body.appendChild(cardElement);

        const targetRect = targetHandElement.getBoundingClientRect();
        // Apuntar la animaciÃ³n al centro del contenedor de la mano para un aterrizaje suave.
        // Restamos la mitad del ancho/alto de la carta para centrarla.
        const cardWidth = 80;
        const cardHeight = 120;
        const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
        const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

        // PequeÃ±o delay para que la transiciÃ³n se aplique correctamente
        setTimeout(() => {
            cardElement.style.transform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;
            
            cardElement.addEventListener('transitionend', () => {
                cardElement.remove(); // Eliminar la carta animada
                const finalCard = createCardElement(deal.card);
                finalCard.style.position = 'absolute'; // Aseguramos que la carta final se pueda posicionar
                targetHandElement.appendChild(finalCard); // AÃ±adir la carta final estÃ¡tica
                applyFanEffect(); // Re-aplicar el abanico en cada carta para un efecto progresivo
                resolve();
            }, { once: true });
        }, 50);
    });
}

// === FUNCIONES AUXILIARES ===

function applyFanEffect() {
    const hands = document.querySelectorAll('.player-cards-hand, .dealer-hand');

    hands.forEach(hand => {
        // Asegurarse de que el contenedor de la mano tenga posiciÃ³n relativa
        hand.style.position = 'relative';
        // Y una altura mÃ­nima para que no colapse si solo tiene elementos absolutos
        if (hand.querySelectorAll('.card').length > 0) {
            hand.style.minHeight = '120px'; // Altura aprox. de una carta
        } else {
            hand.style.minHeight = 'auto'; // Resetear si no hay cartas
        }

        const cards = hand.querySelectorAll('.card');
        const total = cards.length;
        if (total === 0) return;

        const maxAngle = 20; // Ãngulo mÃ¡ximo de rotaciÃ³n
        const horizontalSpread = 30; // PÃ­xeles de separaciÃ³n entre cartas
        const totalWidth = (total - 1) * horizontalSpread;

        cards.forEach((card, index) => {
            const pivotIndex = (total - 1) / 2;
            let angle = 0;
            // Evitar divisiÃ³n por cero si solo hay una carta
            if (total > 1 && pivotIndex > 0) {
                angle = (index - pivotIndex) * (maxAngle / pivotIndex);
            }
            const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);
            
            // Posicionar cada carta desde el centro del contenedor
            card.style.left = '50%';
            // El transform ahora incluye un ajuste para centrar la propia carta (-50% de su ancho)
            // y luego aplica el desplazamiento para el efecto abanico.
            card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
        });
    });
}

function copyRoomCode() {
    if (roomCode) {
        navigator.clipboard.writeText(roomCode)
            .then(() => {
                showNotification('Â¡CÃ³digo copiado al portapapeles!', 'success');
            })
            .catch(err => {
                console.error('Error al copiar:', err);
                // Fallback para navegadores que no soportan clipboard API
                const textArea = document.createElement('textarea');
                textArea.value = roomCode;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showNotification('Â¡CÃ³digo copiado al portapapeles!', 'success');
                } catch (fallbackErr) {
                    showNotification('Error al copiar cÃ³digo', 'error');
                }
                document.body.removeChild(textArea);
            });
    }
}

function showNotification(message, type = 'info') {
    // Remover notificaciones existentes
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => notification.remove());
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);

    // Auto-remover despuÃ©s de 4 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 4000);
    
    console.log(`ðŸ“¢ NotificaciÃ³n [${type.toUpperCase()}]: ${message}`);
}

// FunciÃ³n para salir de la sala 
async function exitRoom() {
    if (confirm('Â¿Seguro que quieres cerrar la sala? Esto desconectarÃ¡ a todos los jugadores.')) {
        try {
            showNotification('Cerrando sala...', 'info');
            
            // Intentar cerrar la sala en el servidor
            const response = await fetch('/salir-mesa', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ codigo: roomCode })
            });
            
            if (response.ok) {
                showNotification('Sala cerrada exitosamente', 'success');
                setTimeout(() => {
                    window.location.href = '/';
                }, 1500);
            } else {
                throw new Error('Error en el servidor');
            }
        } catch (error) {
            console.error('Error al salir de la mesa:', error);
            showNotification('Error al cerrar la sala. Redirigiendo...', 'warning');
            
            // Redirigir de todos modos despuÃ©s de un breve delay
            setTimeout(() => {
                window.location.href = '/';
            }, 2000);
        }
    }
}

// === MANEJO DE ERRORES Y RECONEXIÃ“N ===

// Manejar errores de conexiÃ³n
socket.on('connect_error', (error) => {
    console.error('âŒ Error de conexiÃ³n:', error);
    showNotification('Error de conexiÃ³n al servidor', 'error');
});

// Manejar intentos de reconexiÃ³n
socket.on('reconnect_attempt', (attemptNumber) => {
    console.log(`ðŸ”„ Intento de reconexiÃ³n #${attemptNumber}`);
    showNotification(`Reconectando... (${attemptNumber})`, 'info');
});

// Manejar reconexiÃ³n exitosa
socket.on('reconnect', (attemptNumber) => {
    console.log(`âœ… Reconectado despuÃ©s de ${attemptNumber} intentos`);
    showNotification('Reconectado al servidor', 'success');
    
    // Volver a unirse a la sala
    if (roomCode) {
        socket.emit('joinRoom', roomCode);
    }
});

// === DEBUG Y DESARROLLO ===

// FunciÃ³n de debug para inspeccionar el estado
function debugState() {
    console.log('=== ESTADO ACTUAL ===');
    console.log('roomCode:', roomCode);
    console.log('gameState:', gameState);
    console.log('playersList:', playersList);
    console.log('socket.id:', socket.id);
    console.log('socket.connected:', socket.connected);
    console.log('===================');
}

// Hacer funciÃ³n debug disponible globalmente para testing
window.debugState = debugState;

// Logs adicionales para debugging
console.log('ðŸ”§ Script del dealer cargado exitosamente');
console.log('ðŸ“‹ Funciones disponibles globalmente: debugState()');
    </script>
<body>
</html>