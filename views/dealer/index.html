<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Online -Dealer</title>

    <!-- Favicon personalizado -->
    <link rel="icon" type="image/png" href="/img/logo.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- Google Font para un estilo m√°s moderno -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/header.css">
    <link rel="stylesheet" href="/css/dealer.css">
    <style>
        /* Contenedor para la mano y la puntuaci√≥n del dealer */
        .dealer-hand-container {
            position: relative; /* Permite posicionar elementos hijos de forma absoluta */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

    </style>

</head>

<body>

    <!-- El header reutilizable se insertar√° aqu√≠ desde el servidor -->

    <!-- Animaci√≥n de cartas flotantes -->
    <div class="floating-cards card-1">‚ô¶</div>
    <div class="floating-cards card-2">‚ô†</div>
    <div class="floating-cards card-3">‚ô•</div>
    <div class="floating-cards card-4">‚ô£</div>



    <!-- BOT√ìN FLOTANTE PARA ABRIR CONTROLES (SOLO M√ìVIL) -->
    <button class="open-controls-btn" id="openControlsBtn">
        <i class="fas fa-cogs"></i>
    </button>

    <!-- SIDEBAR -->
    <div class="sidebar" id="dealerControlsModal">
        <!-- PANEL DE CONTROL DEL DEALER -->
        <div class="dealer-controls">
            <h3>Control del Juego</h3>

            <!-- Estado actual -->
            <div class="game-status">
                <div class="status-item">
                    <span>Estado:</span>
                    <span id="gameStateDisplay">Esperando</span>
                </div>
                <div class="status-item">
                    <span>Jugadores:</span>
                    <span id="playersCount">0</span>
                </div>
                <div class="status-item">
                    <span>Confirmados:</span>
                    <span id="confirmedCount">0/0</span>
                </div>
            </div>

            <!-- Botones de control -->
            <div class="control-buttons">
                <!-- Solo el bot√≥n de reiniciar se queda en el panel lateral -->
                <button id="resetGameBtn">
                    <i class="fas fa-redo"></i> REINICIAR
                </button>
            </div>

            <!-- Timer de apuestas -->
            <div class="betting-timer" id="bettingTimer" style="display: none;">
                <div>Tiempo restante:</div>
                <div class="timer-display" id="timerDisplay">30s</div>
                <div class="timer-bar">
                    <div class="timer-progress" id="timerProgress"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- √ÅREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- √ÅREA DE JUGADORES -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>

        <!-- SVG DECORATIVO -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <path id="curve-top" d="M 100 150 Q 500 220 900 150" />
                    <path id="curve-bottom" d="M 100 200 Q 500 270 900 200" />
                    <path id="curve-middle" d="M 100 213 Q 500 283 900 213" />
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>
                <use href="#curve-middle" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK 31 PAYS 3 TO 2
                    </textPath>
                </text>
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 27 AND DRAW TO 26
                    </textPath>
                </text>
            </svg>
        </div>

        <!-- √ÅREA DEL DEALER -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>

            <!-- Contenedor para la mano y la puntuaci√≥n del dealer -->
            <div class="dealer-hand-container">
                <div class="dealer-hand" id="dealerCards">
                    <!-- Las cartas del dealer aparecer√°n aqu√≠ -->
                </div>
                <div id="dealerScoreContainer" class="dealer-score-display" style="display:none;">
                    <span id="dealerScore">Puntos: 0</span>
                </div>
            </div>
        </div>

        <!-- CONTENEDOR PRINCIPAL DE ACCIONES -->
        <div class="main-action-container" id="mainActionContainer">
            <button id="startBettingBtn" class="main-action-btn" style="display: none;"><i class="fas fa-play"></i> INICIAR APUESTAS</button>
            <button id="dealCardsBtn" class="main-action-btn" style="display: none;"><i class="fas fa-layer-group"></i> REPARTIR CARTAS</button>
            <button id="revealCardBtn" class="main-action-btn" style="display: none;"><i class="fas fa-eye"></i> MOSTRAR CARTA</button>
        </div>

        <!-- √ÅREA DE ACCIONES DEL DEALER -->
        <div class="dealer-actions" id="dealerActions" style="display: none;">
            <button id="dealerHitBtn" class="action-btn hit">Pedir</button>
            <button id="dealerStandBtn" class="action-btn stand">Plantarse</button>
        </div>
    </div>

    <!-- Bot√≥n para reabrir el modal de resultados -->
    <div id="viewResultsContainer" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100;">
        <button id="viewResultsBtn" class="main-action-btn" style="background: #8e44ad;">Ver Resultados</button>
    </div>

    <!-- Modal de Fin de Ronda -->
    <div id="endRoundModal" class="end-round-modal" style="display: none;">
        <div class="end-round-modal-content">
            <h2 id="endRoundModalTitle">Ronda Finalizada</h2>
            <span class="close-button" onclick="document.getElementById('endRoundModal').style.display='none'">&times;</span>
            <div id="endRoundModalBody">
                <!-- El contenido se generar√° din√°micamente -->
            </div>
            <button class="action-btn stand" style="margin-top: 20px; background: #7f8c8d;" onclick="document.getElementById('endRoundModal').style.display='none'">Cerrar</button>
        </div>
    </div>


    <!-- Librer√≠a para el efecto de confeti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/header.js"></script>
    <script>

        // Variables globales
        const socket = io();
        let roomCode = '';
        let gameState = 'waiting';
        let playersList = [];
        let bettingTimer = null;

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üéÆ Iniciando vista del dealer...');

            // Extraer c√≥digo de la URL
            const params = new URLSearchParams(window.location.search);
            roomCode = params.get('codigo');

            console.log('üìç C√≥digo de sala detectado:', roomCode);
            if (roomCode) {
                joinRoomAsDealer();
            } else {
                showNotification('No se encontr√≥ c√≥digo de sala', 'error');
                return;
            }
            setupEventListeners();
            setupSocketEvents();
        });

        // Unirse como dealer
        function joinRoomAsDealer() {
            console.log('üéØ Uni√©ndose a la sala como dealer...');
            // Emitir sin playerName para identificarse como dealer
            socket.emit('joinRoom', roomCode);
        }

        // Configurar event listeners
        function setupEventListeners() {
            // Botones de control
            document.getElementById('startBettingBtn').addEventListener('click', startBetting);
            document.getElementById('dealCardsBtn').addEventListener('click', dealCards);
            document.getElementById('revealCardBtn').addEventListener('click', revealDealerCardAction);
            document.getElementById('resetGameBtn').addEventListener('click', resetGame);
            document.getElementById('dealerHitBtn').addEventListener('click', () => socket.emit('dealerHit'));
            document.getElementById('dealerStandBtn').addEventListener('click', () => socket.emit('dealerStand'));

            // Bot√≥n para ver resultados
            document.getElementById('viewResultsBtn').addEventListener('click', () => {
                document.getElementById('endRoundModal').style.display = 'flex';
            });

            // Controles del modal en m√≥vil
            const openControlsBtn = document.getElementById('openControlsBtn');
            const dealerControlsModal = document.getElementById('dealerControlsModal');

            if (openControlsBtn && dealerControlsModal) {
                openControlsBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Evita que el clic se propague al window
                    dealerControlsModal.classList.toggle('active');
                });

                // Listener para cerrar el modal si se hace clic fuera de √©l
                window.addEventListener('click', (e) => {
                    // Si el modal est√° activo Y el clic NO fue dentro del modal Y el clic NO fue en el bot√≥n que lo abre
                    if (dealerControlsModal.classList.contains('active') && !dealerControlsModal.contains(e.target) && !openControlsBtn.contains(e.target)) {
                        dealerControlsModal.classList.remove('active');
                    }
                });
            }
        }

        // Configurar eventos de Socket.IO
        function setupSocketEvents() {
            console.log('üì° Configurando eventos de Socket.IO...');

            // Conexi√≥n establecida
            socket.on('connect', () => {
                console.log('‚úÖ Conectado al servidor con ID:', socket.id);
                showNotification('Conectado al servidor', 'success');
            });

            // Lista de jugadores actualizada
            socket.on('updatePlayerList', (players) => {
                console.log('üë• Lista de jugadores actualizada:', players);
                playersList = players;
                renderPlayers(players);
                updateGameStatus();
            });

            // Estado del juego actualizado
            socket.on('gameStateUpdate', (data) => {
                console.log('üéÆ Estado del juego actualizado:', data);
                gameState = data.state;
                updateGameStateDisplay();
                updateControlButtons();
            });

            // Per√≠odo de apuestas iniciado
            socket.on('bettingStarted', (data) => {
                console.log('üé≤ Per√≠odo de apuestas iniciado:', data);
                showNotification('¬°Per√≠odo de apuestas iniciado!', 'info');
                startBettingTimer(data.duration);
                updateControlButtons();
            });

            // Apuestas cerradas
            socket.on('bettingClosed', () => {
                console.log('‚è∞ Per√≠odo de apuestas cerrado');
                showNotification('Per√≠odo de apuestas cerrado', 'warning');
                stopBettingTimer();
                updateControlButtons();
            });

            // Jugador confirm√≥ apuesta
            socket.on('playerBetConfirmed', (data) => {
                console.log('‚úÖ Jugador confirm√≥ apuesta:', data);
                showNotification(`${data.playerName} confirm√≥ ${data.bet}$`, 'success');
                updateGameStatus();

                // Verificar si todos confirmaron
                const allConfirmed = playersList.every(p => p.betConfirmed);
                if (allConfirmed && playersList.length > 0) {
                    showNotification('¬°Todos confirmaron! Listo para repartir cartas', 'success');
                }
            });

            // Actualizaci√≥n de turno
            socket.on('turnUpdate', (data) => {
                console.log(`[TURN] Turno de: ${data.playerName}`);
                showNotification(`Turno de: ${data.playerName}`, 'info');
                highlightCurrentPlayer(data.playerId);
            });

            // Un jugador pide una carta (Hit)
            socket.on('playerCardUpdate', (data) => {
                console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);

                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'player',
                    id: data.playerId,
                    card: data.newCard
                };
                dealOneCard(dealInfo, deckRect);
            });

            // Un jugador se pasa de 21
            socket.on('playerBust', (data) => {
                console.log(`[BUST] ${data.playerName} se ha pasado.`);
                showNotification(`${data.playerName} se pas√≥ con ${data.score}!`, 'error');
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    const cardsInHand = playerDiv.querySelectorAll('.player-cards-hand .card');
                    cardsInHand.forEach(card => {
                        card.classList.add('busted-card');
                    });
                    playerDiv.classList.add('busted');
                }
            });

            // El turno pasa al dealer
            socket.on('dealerTurn', () => {
                console.log('[DEALER TURN] Turno del dealer.');
                showNotification('Tu turno. Revela tu carta.', 'info');
                // Des-resaltar a todos los jugadores
                highlightCurrentPlayer(null);
                // Ocultar el bot√≥n de repartir y mostrar el de revelar
                document.getElementById('dealCardsBtn').style.display = 'none';
                document.getElementById('revealCardBtn').style.display = 'inline-block';
                document.getElementById('revealCardBtn').disabled = false; // Asegurarse de que est√© habilitado
            });

            // El dealer revela su carta
            socket.on('revealDealerCard', (data) => {
                console.log('[DEALER REVEAL] El dealer revela su mano completa:', data.dealerHand);
                const dealerHandContainer = document.getElementById('dealerCards');

                // Ocultar el bot√≥n una vez que la acci√≥n se completa
                // La funci√≥n revealDealerCardAction() ya se encarga de ocultarlo al hacer clic.

                // Limpiar la mano actual (que contiene cartas ocultas)
                dealerHandContainer.innerHTML = '';

                // Renderizar la mano completa del dealer con todas las cartas visibles
                data.dealerHand.forEach(cardData => {
                    const cardElement = createCardElement(cardData);
                    cardElement.style.position = 'absolute'; // Necesario para el efecto abanico
                    dealerHandContainer.appendChild(cardElement);
                });

                // Re-aplicar el efecto abanico para ajustar las posiciones de todas las cartas
                applyFanEffect();

                // Actualizar la puntuaci√≥n del dealer
                const dealerScore = calculateHandValue(data.dealerHand);
                const scoreContainer = document.getElementById('dealerScoreContainer');
                document.getElementById('dealerScore').textContent = `Puntos: ${dealerScore}`; // <-- CORRECCI√ìN: A√±adir prefijo
                scoreContainer.style.display = 'block';
            });

            // El dealer puede jugar (pedir/plantarse)
            socket.on('dealerCanPlay', () => {
                console.log('[DEALER ACTION] Mostrando botones de Pedir/Plantarse.');
                document.getElementById('dealerActions').style.display = 'flex';
            });

            // El turno del dealer ha terminado (se plant√≥ o se pas√≥)
            socket.on('dealerTurnEnd', () => {
                console.log('[DEALER ACTION] Ocultando botones de Pedir/Plantarse.');
                const dealerActions = document.getElementById('dealerActions');
                if (dealerActions) {
                    dealerActions.style.display = 'none';
                }
            });
            // El dealer pide una carta (Hit)
            socket.on('dealerCardUpdate', (data) => {
                console.log(`[DEALER HIT] Dealer recibe una carta.`);

                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'dealer',
                    card: data.newCard
                };
                // Animar la carta que pide el dealer
                dealOneCard(dealInfo, deckRect).then(() => {
                    // Actualizar la puntuaci√≥n del dealer con el valor que env√≠a el servidor
                    document.getElementById('dealerScore').textContent = `Puntos: ${data.score}`; // <-- CORRECCI√ìN: A√±adir prefijo
                });
            });

            // Resultados del juego
            socket.on('gameResults', (data) => {
                console.log('[RESULTS] Resultados recibidos:', data);
                showNotification('Ronda finalizada. Mostrando resultados...', 'success');
                addResultStyles(); // Asegurarse de que los estilos existan

                // Ocultar el mensaje de turno si existe
                const turnDisplay = document.getElementById('turnDisplay');
                if (turnDisplay) turnDisplay.style.display = 'none';

                // Mostrar el bot√≥n para ver resultados
                document.getElementById('viewResultsContainer').style.display = 'block';

                data.results.forEach(result => {
                    const playerDiv = document.querySelector(`.player-position[data-player-id="${result.playerId}"]`);
                    const playerCards = playerDiv ? playerDiv.querySelectorAll('.player-cards-hand .card') : [];

                    if (playerDiv) {
                        // Aplicar clases a los bordes de las cartas seg√∫n el resultado
                        if (result.outcome === 'WIN' || result.outcome === 'BLACKJACK') {
                            playerCards.forEach(c => c.classList.add('card-win-border'));
                        } else if (result.outcome === 'LOSE') {
                            playerCards.forEach(c => c.classList.add('card-lose-border'));
                        } else if (result.outcome === 'PUSH') {
                            playerCards.forEach(c => c.classList.add('card-push-border'));
                        }
                    }
                });

                // Mostrar la puntuaci√≥n final del dealer
                const dealerHandContainer = document.getElementById('dealerCards');
                const scoreContainer = document.getElementById('dealerScoreContainer');
                let dealerText = `Puntos: ${data.dealerScore}`;
                if (data.dealerScore > 31) dealerText += ' (SE PAS√ì)'; // <-- CORRECCI√ìN: Usar el texto completo
                
                document.getElementById('dealerScore').textContent = dealerText;
                scoreContainer.style.display = 'block';

                // Abrir el modal de fin de ronda despu√©s de un delay para ver los resultados en mesa
                setTimeout(() => {
                    const modal = document.getElementById('endRoundModal');
                    const modalBody = document.getElementById('endRoundModalBody');
                    
                    // Funci√≥n para determinar el resultado general del dealer
                    function getDealerOutcome(results, dealerScore) {
                        const dealerBusted = dealerScore > 31;
                        if (dealerBusted) return 'LOSE';

                        const playerOutcomes = results.map(r => r.outcome);
                        if (playerOutcomes.every(o => o === 'LOSE')) return 'WIN';
                        if (playerOutcomes.every(o => o === 'WIN' || o === 'BLACKJACK' || o === 'PUSH') && playerOutcomes.some(o => o === 'WIN' || o === 'BLACKJACK')) return 'LOSE';
                        
                        return 'PUSH'; // Resultado mixto
                    }

                    const dealerOutcome = getDealerOutcome(data.results, data.dealerScore);

                    // --- L√≥gica de Confeti para el Dealer ---
                    if (typeof confetti === 'function') {
                        const confettiOptions = {
                            particleCount: 150,
                            spread: 120,
                            origin: { y: 0.6 },
                            zIndex: 1600, // Por encima del modal
                            ticks: 300    // 3 segundos de duraci√≥n
                        };

                        switch (dealerOutcome) {
                            case 'WIN':
                                // Confeti de victoria (verde)
                                confetti({
                                    ...confettiOptions,
                                    colors: ['#27ae60', '#2ecc71', '#ffffff']
                                });
                                break;
                            case 'LOSE':
                                // Confeti de derrota (rojo)
                                confetti({
                                    ...confettiOptions,
                                    particleCount: 100,
                                    spread: 70,
                                    colors: ['#e74c3c', '#c0392b']
                                });
                                break;
                            // No hay confeti para el empate (PUSH)
                        }
                    }

                    // 1. Crear una lista combinada y ordenada
                    const allParticipants = [
                        ...data.results.map(r => ({ ...r, type: 'player' })),
                        {
                            playerName: 'Dealer',
                            playerScore: data.dealerScore,
                            type: 'dealer',
                            outcome: dealerOutcome
                        }
                    ];

                    allParticipants.sort((a, b) => {
                        const aWins = a.outcome === 'WIN' || a.outcome === 'BLACKJACK';
                        const bWins = b.outcome === 'WIN' || b.outcome === 'BLACKJACK';
                        if (aWins && !bWins) return -1;
                        if (!aWins && bWins) return 1;
                        const scoreA = a.playerScore > 31 ? -1 : a.playerScore;
                        const scoreB = b.playerScore > 31 ? -1 : b.playerScore;
                        return scoreB - scoreA;
                    });

                    // 2. Crear el HTML
                    let resultsHtml = `
                        <div class="results-list">`;
                    allParticipants.forEach(participant => {
                        let rowClass = participant.type === 'dealer' ? 'results-row dealer-row' : 'results-row';
                        const outcome = participant.outcome;
                        if (outcome === 'WIN' || outcome === 'BLACKJACK') { rowClass += ' winner-row'; } 
                        else if (outcome === 'LOSE') { rowClass += ' loser-row'; } 
                        else if (outcome === 'PUSH') { rowClass += ' push-row'; }

                        resultsHtml += `
                            <div class="${rowClass}">
                                <span>${participant.playerName}</span>
                                <span>${participant.playerScore > 31 ? `Se pas√≥ (${participant.playerScore})` : participant.playerScore}</span>
                            </div>`;
                    });
                    resultsHtml += '</div><p class="waiting-next-round">Puedes reiniciar el juego cuando est√©s listo.</p>';

                    modalBody.innerHTML = resultsHtml;
                    modal.style.display = 'flex';
                }, 3000); // 3 segundos de espera
            });

            // Errores
            socket.on('error', (data) => {
                console.error('‚ùå Error del servidor:', data);
                showNotification('Error: ' + data.message, 'error');
            });

            // Desconexi√≥n
            socket.on('disconnect', () => {
                console.log('‚ùå Desconectado del servidor');
                showNotification('Desconectado del servidor', 'error');
            });

            // Juego reiniciado
            socket.on('gameReset', () => {
                console.log('üîÑ Juego reiniciado por el servidor.');
                showNotification('El juego ha sido reiniciado.', 'info');
                // Limpiar manos y highlights
                document.getElementById('dealerCards').innerHTML = '';
                document.querySelectorAll('.player-cards-hand').forEach(hand => hand.innerHTML = '');
                document.getElementById('dealerScoreContainer').style.display = 'none';
                document.querySelectorAll('.player-position').forEach(div => {
                    div.classList.remove('current-turn');
                    div.classList.remove('busted');
                    // Remover overlays de resultados
                    const overlay = div.querySelector('.result-overlay');
                    if (overlay) overlay.remove();
                });
                document.getElementById('startBettingBtn').style.display = 'none';
                document.getElementById('dealCardsBtn').style.display = 'none';
                document.getElementById('revealCardBtn').style.display = 'none';
                document.getElementById('revealCardBtn').disabled = false; // Resetear para la siguiente ronda
                // Remover puntuaci√≥n del dealer
                document.getElementById('viewResultsContainer').style.display = 'none';
                document.getElementById('dealerActions').style.display = 'none';
                // Ocultar modal de fin de ronda si est√° abierto
                const endRoundModal = document.getElementById('endRoundModal');
                if (endRoundModal) endRoundModal.style.display = 'none';
                stopBettingTimer();
            });
            
            // Evento para confirmar que la reconexi√≥n fue exitosa
            socket.on('reconnectedSuccessfully', () => {
                console.log('‚úÖ Reconexi√≥n a la sala confirmada por el servidor.');
                showNotification('Reconectado a la sala', 'success');
            });
        }

        // === FUNCIONES DE RENDERIZADO ===

        function renderPlayers(players) {
            const playerCardsContainer = document.getElementById('playerCards');
            const activePlayers = players.filter(p => !p.disconnected);

            if (activePlayers.length === 0) {
                playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
                return;
            }

            playerCardsContainer.innerHTML = '';

            activePlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-position';
                playerDiv.dataset.playerId = player.id;

                let betDisplay = '';
                let floatingBetHtml = '';

                if (player.bet > 0) {
                    const chipStack = getChipStackHtml(player.bet);
                    const statusClass = player.betConfirmed ? 'bet-confirmed-icon' : 'bet-pending';
                    const statusText = player.betConfirmed ? '' : ' (Esperando)';
                    betDisplay = `<div class="${statusClass}">${chipStack} <span class="bet-total-text">${player.bet}$${statusText}</span></div>`;
                    betDisplay = `<div class="${statusClass}">${chipStack}</div>`;
                } else {
                    betDisplay = `<div class="no-bet">Sin apuesta</div>`;
                }

                playerDiv.innerHTML = `
            <div class="player-header">
                <div class="player-name-display">${player.name}</div>
            </div>
            <div class="player-cards-hand">
                <div class="card-slot">Esperando cartas...</div>
            </div>
            <div class="player-bet">${betDisplay}</div>
            ${floatingBetHtml}`;

                playerCardsContainer.appendChild(playerDiv);
            });
        }

        function addPlayerStyles() {
            if (document.getElementById('dealer-player-styles')) return;
            const style = document.createElement('style');
            style.id = 'dealer-player-styles'; // ID corregido para evitar duplicados
            style.innerHTML = `
        .player-bet .chip-stack {
            position: relative;
            display: inline-block;
            width: 30px;
            height: 40px; /* Espacio para la pila */
            vertical-align: middle;
            margin-right: 5px;
        }
        .player-bet .stacked-chip {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 30px;
            height: 30px;
            transition: transform 0.2s;
        }
        .bet-total-text {
            vertical-align: middle;
        }
        .bet-confirmed-icon, .bet-pending {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .bet-confirmed-icon {
            color: #27ae60;
        }
        .bet-pending {
            color: #f39c12;
            animation: blink 1.5s infinite;
        }
        .player-position.busted {
            background:rgba(0, 0, 0, 0.107);
            border-color: #e74c3c;
            opacity: 0.8;
        }
        .player-position.busted::after {
            content: 'BUST';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 2.5em; font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 2px 2px 5px #000;
            pointer-events: none;
        }
        .player-cards-hand .busted-card {
            border-color: #e74c3c;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.7);
            opacity: 0.8;
        }`;
            document.head.appendChild(style);
        }

        function addResultStyles() {
            if (document.getElementById('game-result-styles')) return;
            const style = document.createElement('style');
            style.id = 'game-result-styles';
            style.innerHTML = `
        .result-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 15;
            text-align: center;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .result-overlay .outcome-text {
            font-size: 2.5em;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 2px 2px 5px #000;
        }
        .result-overlay .score-text {
            font-size: 1.2em;
            margin-top: 5px;
        }
        .result-overlay.result-win, .result-overlay.result-blackjack { background: rgba(39, 174, 96, 0.7); }
        .result-overlay.result-lose { background: rgba(192, 57, 43, 0.7); }
        .result-overlay.result-push { background: rgba(44, 62, 80, 0.7); }

        /* Estilos para los bordes de las cartas de resultado */
        .card.card-win-border {
            border: 4px solid #2ecc71 !important; box-shadow: 0 0 15px rgba(46, 204, 113, 0.9) !important;
        }
        .card.card-lose-border {
            border: 4px solid #e74c3c !important; box-shadow: 0 0 15px rgba(231, 76, 60, 0.9) !important;
        }
        .card.card-push-border {
            border: 4px solid #95a5a6 !important; box-shadow: 0 0 15px rgba(149, 165, 166, 0.9) !important;
        }
        

        /* Estilos para el modal de fin de ronda (copiados de players.css) */
        .end-round-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            /* display: flex se controla con JS, no debe estar aqu√≠ con !important */
            align-items: center !important;
            justify-content: center !important;
            background: rgba(0, 0, 0, 0.85) !important;
            z-index: 1500 !important;
        }

        .end-round-modal-content {
            background: rgba(10, 10, 10, 0.95) !important;
            padding: 40px !important; border-radius: 15px !important; border: 2px solid #D4AF37 !important;
            min-width: 400px !important; max-width: 90vw !important;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3) !important;
            position: relative !important; overflow-y: auto !important;
            margin: 0 !important;
            transform: none !important;
        }
        .close-button {
            color: #aaa; position: absolute; top: 10px; right: 20px;
            font-size: 28px; font-weight: bold; cursor: pointer; z-index: 10;
        }
        .close-button:hover { color: white; }

        /* Estilos para la lista de resultados en el modal */
        .results-list { width: 100%; margin-bottom: 20px; }
        .results-header, .results-row {
            display: flex; justify-content: space-between;
            padding: 10px 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .results-header {
            font-weight: bold; color: #D4AF37; background: rgba(255, 255, 255, 0.05);
            border-top-left-radius: 8px; border-top-right-radius: 8px;
        }
        .results-row.dealer-row {
            color: #FFD700;
            font-weight: bold;
        }
        .results-row span:last-child { font-weight: bold; }
        .end-round-modal-content {
            font-family: 'Poppins', sans-serif;
        }
        .winner-row {
            background: linear-gradient(90deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.1));
            color: #f5f5f5 !important;
            border-left: 4px solid #27ae60;
            border-radius: 8px;
        }
        .loser-row {
            background: linear-gradient(90deg, rgba(192, 57, 43, 0.25), rgba(192, 57, 43, 0.05));
            color: #a0a0a0 !important;
            border-left: 4px solid #c0392b;
            border-radius: 8px;
            opacity: 0.8;
        }
        .push-row {
            background: linear-gradient(90deg, rgba(41, 128, 185, 0.25), rgba(41, 128, 185, 0.05));
            color: #bdc3c7 !important;
            border-left: 4px solid #2980b9;
            border-radius: 8px;
        }
        .waiting-next-round {
            text-align: center; font-style: italic; margin-top: 15px; color: #ccc;
        }
    `;
            document.head.appendChild(style);
        }

        // === FUNCIONES DE CONTROL ===

        function highlightCurrentPlayer(playerId) {
            // Remover highlight de todos los jugadores primero
            document.querySelectorAll('.player-position').forEach(div => {
                div.classList.remove('current-turn');
            });

            if (!playerId) {
                // Si no hay ID de jugador, es el turno del dealer o un estado intermedio.
                return;
            }

            // Agregar highlight al jugador actual
            const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
            if (playerDiv) {
                playerDiv.classList.add('current-turn');
            }
        }

        function updateGameStatus() {
            const playersCount = playersList.length;
            const confirmedCount = playersList.filter(p => p.betConfirmed).length;

            document.getElementById('contador').textContent = playersCount;
            document.getElementById('playersCount').textContent = playersCount;
            document.getElementById('confirmedCount').textContent = `${confirmedCount}/${playersCount}`;

            updateControlButtons();
            addPlayerStyles(); // Asegurarse de que los estilos de 'busted' existan
        }

        function updateGameStateDisplay() {
            const display = document.getElementById('gameStateDisplay');
            display.className = `game-state-${gameState}`;

            const stateNames = {
                waiting: 'Esperando',
                betting: 'Apostando',
                playing: 'Jugando',
                finished: 'Finalizado'
            };

            display.textContent = stateNames[gameState] || gameState;
        }

        function updateControlButtons() {
            const startBettingBtn = document.getElementById('startBettingBtn');
            const dealCardsBtn = document.getElementById('dealCardsBtn');
            const revealCardBtn = document.getElementById('revealCardBtn');

            console.log(`Actualizando botones - Estado: ${gameState}, Jugadores: ${playersList.length}`);

            // Ocultar todos los botones de acci√≥n principal por defecto
            startBettingBtn.style.display = 'none';
            dealCardsBtn.style.display = 'none';
            // El bot√≥n de revelar se gestiona en su propio evento 'dealerTurn' para mayor precisi√≥n.

            // L√≥gica para mostrar el bot√≥n correcto
            // 1. Mostrar "Iniciar Apuestas" si estamos esperando y hay jugadores
            if (gameState === 'waiting' && playersList.length > 0) {
                startBettingBtn.style.display = 'inline-block';
                return; // Salimos para no mostrar otro bot√≥n por error
            }

            // 2. Mostrar "Repartir Cartas" si estamos jugando, todos confirmaron y el dealer no tiene cartas
            const allConfirmed = playersList.length > 0 && playersList.every(p => p.betConfirmed);
            const dealerHasCards = document.getElementById('dealerCards').children.length > 0;

            if (gameState === 'playing' && allConfirmed && !dealerHasCards) {
                dealCardsBtn.style.display = 'inline-block';
            }
        }

        function revealDealerCardAction() {
            console.log('-> Emitiendo dealerRevealCard');
            document.getElementById('revealCardBtn').style.display = 'none'; // Ocultar al hacer clic
            socket.emit('dealerRevealCard');
        }

        // === FUNCIONES DE TIMER ===

        function startBettingTimer(duration) {
            const timerElement = document.getElementById('bettingTimer');
            const displayElement = document.getElementById('timerDisplay');
            const progressElement = document.getElementById('timerProgress');

            timerElement.style.display = 'block';
            let timeLeft = duration;

            // Actualizaci√≥n inicial
            const seconds = Math.ceil(timeLeft / 1000);
            displayElement.textContent = `${seconds}s`;
            progressElement.style.width = '100%';

            bettingTimer = setInterval(() => {
                timeLeft -= 1000;

                const seconds = Math.ceil(timeLeft / 1000);
                displayElement.textContent = `${seconds}s`;

                const progressPercent = Math.max(0, (timeLeft / duration) * 100);
                progressElement.style.width = `${progressPercent}%`;

                // Cambiar color cuando quedan pocos segundos
                if (seconds <= 10) {
                    displayElement.style.color = '#ff4757';
                    progressElement.style.background = 'linear-gradient(90deg, #ff4757, #ff6b6b)';
                }

                if (timeLeft <= 0) {
                    stopBettingTimer();
                }
            }, 1000);
        }

        function stopBettingTimer() {
            if (bettingTimer) {
                clearInterval(bettingTimer);
                bettingTimer = null;
            }

            const timerElement = document.getElementById('bettingTimer');
            const displayElement = document.getElementById('timerDisplay');
            const progressElement = document.getElementById('timerProgress');

            timerElement.style.display = 'none';

            // Resetear estilos
            displayElement.style.color = '#ff6b6b';
            progressElement.style.background = 'linear-gradient(90deg, #ff6b6b, #ffa500)';
        }

        // === FUNCIONES DE CONTROL DEL JUEGO ===

        function startBetting() {
            console.log('üéØ Iniciando per√≠odo de apuestas...');

            if (playersList.length === 0) {
                showNotification('No hay jugadores en la sala', 'warning');
                return;
            }

            if (gameState !== 'waiting') {
                showNotification('No se puede iniciar apuestas en este momento', 'warning');
                return;
            }

            const duration = 30000; // 30 segundos
            console.log('üì° Emitiendo evento startBetting con duraci√≥n:', duration);

            // Deshabilitar bot√≥n inmediatamente para evitar m√∫ltiples clics
            document.getElementById('startBettingBtn').style.display = 'none';

            socket.emit('startBetting', duration);

            // Feedback visual inmediato
            showNotification('Iniciando per√≠odo de apuestas...', 'info');
        }

        function dealCards() {
            console.log('üé∞ Repartiendo cartas...');

            const allConfirmed = playersList.every(p => p.betConfirmed);
            if (!allConfirmed || playersList.length === 0) {
                showNotification('No todos los jugadores han confirmado sus apuestas', 'warning');
                return;
            }

            // Ocultar bot√≥n para evitar clics m√∫ltiples
            document.getElementById('dealCardsBtn').style.display = 'none';

            // Emitir evento al servidor para que reparta las cartas
            socket.emit('dealCards');
        }

        function resetGame() {
            if (confirm('¬øSeguro que quieres reiniciar el juego? Esto limpiar√° todas las apuestas.')) {
                console.log('üîÑ Reiniciando juego...');

                socket.emit('resetGame');
                showNotification('Reiniciando juego...', 'info');

                // Limpiar timer si est√° activo
                stopBettingTimer();

                // Resetear estado local
                gameState = 'waiting';
                updateGameStateDisplay();
                updateControlButtons();
            }
        }

        // === L√ìGICA DE ANIMACI√ìN DE CARTAS ===

        socket.on('cardsDealt', (data) => {
            console.log('üÉè Recibiendo cartas del servidor:', data);

            // Limpiar manos actuales antes de repartir
            document.getElementById('dealerCards').innerHTML = '';
            document.querySelectorAll('.player-cards-hand').forEach(hand => {
                hand.innerHTML = '';
            });

            // Aunque el dealer conoce su mano completa (data.dealer), para la animaci√≥n
            // inicial, debemos mostrar las cartas como las ven los jugadores.
            // La mano completa del dealer (`data.dealer`) se usar√° para renderizar el estado final.
            const dealerHandForDisplay = [
                { hidden: true }, // Primera carta oculta para la animaci√≥n
                { hidden: true }, // Segunda carta oculta para la animaci√≥n
                data.dealer[2]    // Tercera carta visible
            ];
            animateDealing(data.players, dealerHandForDisplay, data.dealer);
        });

        function createCardElement(card) {
            const cardDiv = document.createElement('div');

            if (card.hidden) {
                // Si la carta est√° marcada como oculta, usamos el reverso.
                // Esto es crucial para la animaci√≥n inicial.
                cardDiv.className = 'card card-back'; 
                return cardDiv; 
            }

            // Usar la imagen de la carta como fondo
            cardDiv.className = 'card';
            cardDiv.style.backgroundImage = `url('/${card.src}')`;
            // Opcional: puedes dejar el texto superpuesto si tu CSS lo permite
            return cardDiv;
        }

        async function animateDealing(players, dealerHandForAnimation, dealerFullHand) {
            const deckElement = document.querySelector('.deck-pile');
            if (!deckElement) return;

            const deckRect = deckElement.getBoundingClientRect();
            const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

            const dealSequence = [];

            // Ronda 1: Jugadores -> Dealer
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHandForAnimation[0] }); // Carta de animaci√≥n (oculta)

            // Ronda 2: Jugadores -> Dealer
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHandForAnimation[1] }); // Carta de animaci√≥n (oculta)

            // Ronda 3: Jugadores -> Dealer
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[2] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHandForAnimation[2] }); // Carta de animaci√≥n (visible)


            for (const deal of dealSequence) {
                await dealOneCard(deal, deckRect);
            }

            // Despu√©s de la animaci√≥n, renderizamos la mano del dealer como la ven los jugadores
            // (2 ocultas, 1 visible), que es el estado inicial antes de que el dealer revele su carta.
            const dealerHandContainer = document.getElementById('dealerCards');
            dealerHandContainer.innerHTML = ''; // Limpiar la mano animada

            dealerHandForAnimation.forEach(cardData => {
                const cardElement = createCardElement(cardData);
                cardElement.style.position = 'absolute';
                dealerHandContainer.appendChild(cardElement);
            });

            // La puntuaci√≥n del dealer no se muestra en este punto, solo la carta visible.
            // Se calcular√° y mostrar√° cuando se revele la mano completa.
            const scoreContainer = document.getElementById('dealerScoreContainer');
            scoreContainer.style.display = 'none';

            applyFanEffect();
        }

        function getChipStackHtml(bet) {
            if (bet <= 0) return '';

            let chipStackHtml = '<div class="chip-stack">';
            let tempBet = bet;
            const chipDenominations = [100, 50, 25, 10];
            let zIndex = 1;
            let offset = 0;
            const maxChipsPerStack = 5; // Para evitar pilas demasiado altas

            for (const denomination of chipDenominations) {
                let count = Math.floor(tempBet / denomination);
                count = Math.min(count, maxChipsPerStack); // Limitar chips por denominaci√≥n
                for (let i = 0; i < count; i++) {
                    chipStackHtml += `<img src="/img/${denomination}-chip.png" class="stacked-chip" style="z-index: ${zIndex}; transform: translateY(-${offset}px);" alt="${denomination}$">`;
                    zIndex++;
                    offset += 4; // Peque√±o desplazamiento para cada ficha
                }
                tempBet -= count * denomination;
            }
            chipStackHtml += '</div>';
            return chipStackHtml;
        }

        function dealOneCard(deal, deckRect) {
            return new Promise(resolve => {
                let targetHandElement;
                if (deal.target === 'player') {
                    targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
                } else {
                    targetHandElement = document.getElementById('dealerCards');
                }

                if (!targetHandElement) {
                    console.warn(`No se encontr√≥ el contenedor de mano para ${deal.target} ${deal.id || ''}`);
                    return resolve();
                }

                const cardElement = createCardElement(deal.card);
                cardElement.classList.add('dealing-animation');
                cardElement.style.left = `${deckRect.left}px`;
                cardElement.style.top = `${deckRect.top}px`;

                document.body.appendChild(cardElement);

                const targetRect = targetHandElement.getBoundingClientRect();
                // Apuntar la animaci√≥n al centro del contenedor de la mano para un aterrizaje suave.
                // Restamos la mitad del ancho/alto de la carta para centrarla.
                const cardWidth = 80;
                const cardHeight = 120;
                const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
                const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

                // Peque√±o delay para que la transici√≥n se aplique correctamente
                setTimeout(() => {
                    cardElement.style.transform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;

                    cardElement.addEventListener('transitionend', () => {
                        cardElement.remove(); // Eliminar la carta animada
                        const finalCard = createCardElement(deal.card);
                        finalCard.style.position = 'absolute'; // Aseguramos que la carta final se pueda posicionar
                        targetHandElement.appendChild(finalCard); // A√±adir la carta final est√°tica
                        applyFanEffect(); // Re-aplicar el abanico en cada carta para un efecto progresivo
                        resolve();
                    }, { once: true });
                }, 50);
            });
        }

        // === FUNCIONES AUXILIARES ===

        function applyFanEffect() {
            const hands = document.querySelectorAll('.player-cards-hand, .dealer-hand');

            hands.forEach(hand => {
                hand.style.position = 'relative';

                const cards = hand.querySelectorAll('.card');
                const total = cards.length;
                if (total === 0) return;

                const maxAngle = 20; // √Ångulo m√°ximo de rotaci√≥n
                const horizontalSpread = window.innerWidth < 768 ? 20 : 30; // Separaci√≥n de cartas responsive
                const totalWidth = (total - 1) * horizontalSpread;

                cards.forEach((card, index) => {
                    const pivotIndex = (total - 1) / 2;
                    let angle = 0;
                    // Evitar divisi√≥n por cero si solo hay una carta
                    if (total > 1 && pivotIndex > 0) {
                        angle = (index - pivotIndex) * (maxAngle / pivotIndex);
                    }
                    const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);

                    // Posicionar cada carta desde el centro del contenedor
                    card.style.left = '50%';
                    // El transform ahora incluye un ajuste para centrar la propia carta (-50% de su ancho)
                    // y luego aplica el desplazamiento para el efecto abanico.
                    card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
                });
            });
        }

        function copyRoomCode() {
            if (roomCode) {
                navigator.clipboard.writeText(roomCode)
                    .then(() => {
                        showNotification('¬°C√≥digo copiado al portapapeles!', 'success');
                    })
                    .catch(err => {
                        console.error('Error al copiar:', err);
                        // Fallback para navegadores que no soportan clipboard API
                        const textArea = document.createElement('textarea');
                        textArea.value = roomCode;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            showNotification('¬°C√≥digo copiado al portapapeles!', 'success');
                        } catch (fallbackErr) {
                            showNotification('Error al copiar c√≥digo', 'error');
                        }
                        document.body.removeChild(textArea);
                    });
            }
        }

        function showNotification(message, type = 'info') {
            // Remover notificaciones existentes
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => notification.remove());

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;

            document.body.appendChild(notification);

            // Auto-remover despu√©s de 4 segundos
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 4000);

            console.log(`üì¢ Notificaci√≥n [${type.toUpperCase()}]: ${message}`);
        }

        // Nueva funci√≥n para calcular el valor de la mano del dealer desde el DOM
        function calculateHandValueFromDOM() {
            const dealerHandContainer = document.getElementById('dealerCards');
            const cards = dealerHandContainer.querySelectorAll('.card:not(.card-back)');
            let sum = 0;
            let aces = 0;
            
            // Esta es una simulaci√≥n porque no tenemos los datos de la carta en el DOM.
            // La forma correcta ser√≠a tener los datos en una variable global.
            // Por ahora, vamos a usar una funci√≥n de ayuda que simula esto.
            // En un futuro, deber√≠amos guardar la mano del dealer en una variable.
            // Esta es una limitaci√≥n del enfoque actual.
            // La l√≥gica real de c√°lculo est√° en el servidor, aqu√≠ solo mostramos.
            // Vamos a recalcular bas√°ndonos en los datos que s√≠ tenemos.
            // ¬°He encontrado una mejor manera! Usaremos la funci√≥n `calculateHandValue` que ya existe.
            return 0; // Este valor se actualizar√° desde los eventos del socket.
        }

        // Funci√≥n para calcular el valor de la mano (copiada de sockets.js para uso en cliente)
        function calculateHandValue(hand) {
            let sum = 0;
            let aces = 0;
            for (const card of hand) {
                if (card.hidden) continue;
                sum += card.points;
                if (card.value === 'A') aces++;
            }
            while (sum > 31 && aces > 0) {
                sum -= 10;
                aces--;
            }
            return sum;
        }
        // Funci√≥n para salir de la sala 
        async function exitRoom() {
            // No se necesita confirmaci√≥n, la salida es inmediata.
            showNotification('Cerrando sala...', 'info');

            // Emitir un evento al servidor para que cierre la sala inmediatamente para todos.
            socket.emit('dealerExit');
            // Redirigir al dealer a la p√°gina de inicio de inmediato.
            window.location.href = '/';
        }

        // === MANEJO DE ERRORES Y RECONEXI√ìN ===

        // Manejar errores de conexi√≥n
        socket.on('connect_error', (error) => {
            console.error('‚ùå Error de conexi√≥n:', error);
            showNotification('Error de conexi√≥n al servidor', 'error');
        });

        // Manejar intentos de reconexi√≥n
        socket.on('reconnect_attempt', (attemptNumber) => {
            console.log(`üîÑ Intento de reconexi√≥n #${attemptNumber}`);
            showNotification(`Reconectando... (${attemptNumber})`, 'info');
        });

        // Manejar reconexi√≥n exitosa
        socket.on('reconnect', (attemptNumber) => {
            console.log(`‚úÖ Reconectado despu√©s de ${attemptNumber} intentos`);
            showNotification('Reconectado al servidor', 'success');

            // Volver a unirse a la sala
            if (roomCode) {
                socket.emit('joinRoom', roomCode);
            }
        });

        // === DEBUG Y DESARROLLO ===

        // Funci√≥n de debug para inspeccionar el estado
        function debugState() {
            console.log('=== ESTADO ACTUAL ===');
            console.log('roomCode:', roomCode);
            console.log('gameState:', gameState);
            console.log('playersList:', playersList);
            console.log('socket.id:', socket.id);
            console.log('socket.connected:', socket.connected);
            console.log('===================');
        }

        // Hacer funci√≥n debug disponible globalmente para testing
        window.debugState = debugState;

        // Logs adicionales para debugging
        console.log('üîß Script del dealer cargado exitosamente');
        console.log('üìã Funciones disponibles globalmente: debugState()');
    </script>
</body>
</html>