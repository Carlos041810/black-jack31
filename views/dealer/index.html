<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Online - Vista del Dealer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="/css/dealer.css">
</head>

<body>
    <!-- HEADER -->
    <header class="top-bar">
        <div class="left-group">
            <button class="exit-btn" onclick="exitRoom()">
                <i class="fas fa-door-open"></i> EXIT ROOM
            </button>
            <div class="invite-section">
                <span id="roomCodeText">Código: </span>
                <button id="copyBtn">COPY</button>
            </div>
        </div>
        <div class="dealer-title">DEALER VIEW</div>
        <button class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </button>
        <nav class="mobile-menu" id="mobileMenu">
            <button class="how-to-play">🔊 HOW TO PLAY</button>
            <button class="exit-btn" onclick="exitRoom()">EXIT</button>
            <button onclick="copyRoomCode()">COPY INVITE</button>
        </nav>
        <button class="how-to-play desktop-only">🔊 HOW TO PLAY</button>
    </header>

    <!-- SIDEBAR -->
    <div class="sidebar">
        <div class="online-status">
            <div class="status-icon"></div>
            <span class="user-icon">👥</span>
            <h2 id="contador">0</h2>
        </div>
        
        <!-- PANEL DE CONTROL DEL DEALER -->
        <div class="dealer-controls">
            <h3>Control del Juego</h3>
            
            <!-- Estado actual -->
            <div class="game-status">
                <div class="status-item">
                    <span>Estado:</span>
                    <span id="gameStateDisplay">Esperando</span>
                </div>
                <div class="status-item">
                    <span>Jugadores:</span>
                    <span id="playersCount">0</span>
                </div>
                <div class="status-item">
                    <span>Confirmados:</span>
                    <span id="confirmedCount">0/0</span>
                </div>
            </div>

            <!-- Botones de control -->
            <div class="control-buttons">
                <button id="startBettingBtn">
                    <i class="fas fa-play"></i> INICIAR APUESTAS
                </button>
                
                <button id="dealCardsBtn" disabled>
                    <i class="fas fa-layer-group"></i> REPARTIR CARTAS
                </button>
                
                <button id="revealCardBtn" style="display: none;">
                    <i class="fas fa-eye"></i> MOSTRAR CARTA
                </button>
                
                <button id="resetGameBtn">
                    <i class="fas fa-redo"></i> REINICIAR
                </button>
            </div>

            <!-- Timer de apuestas -->
            <div class="betting-timer" id="bettingTimer" style="display: none;">
                <div>Tiempo restante:</div>
                <div class="timer-display" id="timerDisplay">30s</div>
                <div class="timer-bar">
                    <div class="timer-progress" id="timerProgress"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ÁREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- ÁREA DE JUGADORES -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>
        
        <!-- SVG DECORATIVO -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <path id="curve-top" d="M 150 150 Q 500 50 850 150" />
                    <path id="curve-bottom" d="M 150 200 Q 500 100 850 200" />
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>
                <path d="M 150 250 Q 500 150 850 250" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56" text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK PAY 3 TO 2
                    </textPath>
                </text>
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36" text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 17 AND DRAW TO 16
                    </textPath>
                </text>
            </svg>
        </div>
        
        <!-- ÁREA DEL DEALER -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>

            <!-- Las cartas que el dealer se reparte a sí mismo -->
            <div class="dealer-hand" id="dealerCards">
                <!-- Las cartas del dealer aparecerán aquí cuando se repartan -->
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>

        // Variables globales
const socket = io();
let roomCode = '';
let gameState = 'waiting';
let playersList = [];
let bettingTimer = null;

// Inicialización
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎮 Iniciando vista del dealer...');
    
    // Extraer código de la URL
    const params = new URLSearchParams(window.location.search);
    roomCode = params.get('codigo');
    
    console.log('📍 Código de sala detectado:', roomCode);

    if (roomCode) {
        setupRoomCode();
        joinRoomAsDealer();
    } else {
        showNotification('No se encontró código de sala', 'error');
        return;
    }

    setupEventListeners();
    setupSocketEvents();
});

// Configurar código de sala
function setupRoomCode() {
    const roomCodeText = document.getElementById('roomCodeText');
    const copyBtn = document.getElementById('copyBtn');

    roomCodeText.textContent = `Código: ${roomCode}`;
    
    copyBtn.onclick = copyRoomCode;
}

// Unirse como dealer
function joinRoomAsDealer() {
    console.log('🎯 Uniéndose a la sala como dealer...');
    // Emitir sin playerName para identificarse como dealer
    socket.emit('joinRoom', roomCode);
}

// Configurar event listeners
function setupEventListeners() {
    // Menú hamburguesa
    const menuToggle = document.getElementById('menuToggle');
    const mobileMenu = document.getElementById('mobileMenu');

    if (menuToggle && mobileMenu) {
        menuToggle.addEventListener('click', () => {
            mobileMenu.classList.toggle('active');
        });
    }

    // Botones de control
    document.getElementById('startBettingBtn').addEventListener('click', startBetting);
    document.getElementById('dealCardsBtn').addEventListener('click', dealCards);
    document.getElementById('revealCardBtn').addEventListener('click', revealDealerCardAction);
    document.getElementById('resetGameBtn').addEventListener('click', resetGame);
}

// Configurar eventos de Socket.IO
function setupSocketEvents() {
    console.log('📡 Configurando eventos de Socket.IO...');

    // Conexión establecida
    socket.on('connect', () => {
        console.log('✅ Conectado al servidor con ID:', socket.id);
        showNotification('Conectado al servidor', 'success');
    });

    // Lista de jugadores actualizada
    socket.on('updatePlayerList', (players) => {
        console.log('👥 Lista de jugadores actualizada:', players);
        playersList = players;
        renderPlayers(players);
        updateGameStatus();
    });

    // Estado del juego actualizado
    socket.on('gameStateUpdate', (data) => {
        console.log('🎮 Estado del juego actualizado:', data);
        gameState = data.state;
        updateGameStateDisplay();
        updateControlButtons();
    });

    // Período de apuestas iniciado
    socket.on('bettingStarted', (data) => {
        console.log('🎲 Período de apuestas iniciado:', data);
        showNotification('¡Período de apuestas iniciado!', 'info');
        startBettingTimer(data.duration);
        updateControlButtons();
    });

    // Apuestas cerradas
    socket.on('bettingClosed', () => {
        console.log('⏰ Período de apuestas cerrado');
        showNotification('Período de apuestas cerrado', 'warning');
        stopBettingTimer();
        updateControlButtons();
    });

    // Jugador confirmó apuesta
    socket.on('playerBetConfirmed', (data) => {
        console.log('✅ Jugador confirmó apuesta:', data);
        showNotification(`${data.playerName} confirmó $${data.bet}`, 'success');
        updateGameStatus();
        
        // Verificar si todos confirmaron
        const allConfirmed = playersList.every(p => p.betConfirmed);
        if (allConfirmed && playersList.length > 0) {
            showNotification('¡Todos confirmaron! Listo para repartir cartas', 'success');
        }
    });

    // Actualización de turno
    socket.on('turnUpdate', (data) => {
        console.log(`[TURN] Turno de: ${data.playerName}`);
        showNotification(`Turno de: ${data.playerName}`, 'info');
        highlightCurrentPlayer(data.playerId);
    });

    // Un jugador pide una carta (Hit)
    socket.on('playerCardUpdate', (data) => {
        console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);
        
        const deckElement = document.querySelector('.deck-pile');
        if (!deckElement) return;
        const deckRect = deckElement.getBoundingClientRect();

        const dealInfo = {
            target: 'player',
            id: data.playerId,
            card: data.newCard
        };
        dealOneCard(dealInfo, deckRect);
    });

    // Un jugador se pasa de 21
    socket.on('playerBust', (data) => {
        console.log(`[BUST] ${data.playerName} se ha pasado.`);
        showNotification(`${data.playerName} se pasó con ${data.score}!`, 'error');
        const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
        if (playerDiv) {
            playerDiv.classList.add('busted');
        }
    });

    // El turno pasa al dealer
    socket.on('dealerTurn', () => {
        console.log('[DEALER TURN] Turno del dealer.');
        showNotification('Tu turno. Revela tu carta.', 'info');
        // Des-resaltar a todos los jugadores
        highlightCurrentPlayer(null);
        // Mostrar el botón para revelar la carta
        document.getElementById('revealCardBtn').style.display = 'inline-block';
        updateControlButtons();
    });

    // El dealer revela su carta
    socket.on('revealDealerCard', (data) => {
        console.log('[DEALER REVEAL] El dealer revela su mano:', data.dealerHand);
        const dealerHandContainer = document.getElementById('dealerCards');
        // Ocultar el botón una vez que la acción se completa
        document.getElementById('revealCardBtn').style.display = 'none';
        const hiddenCard = dealerHandContainer.querySelector('.card-back');
        
        if (hiddenCard && data.dealerHand.length > 1) {
            const revealedCardData = data.dealerHand[1];
            const revealedCardElement = createCardElement(revealedCardData);
            revealedCardElement.style.position = 'absolute'; // Mantener posicionamiento para el abanico

            // Reemplazo simple
            hiddenCard.replaceWith(revealedCardElement);
            
            // Re-aplicar el efecto abanico para ajustar las posiciones de todas las cartas
            applyFanEffect();
        }
    });

    // Resultados del juego
    socket.on('gameResults', (data) => {
        console.log('[RESULTS] Resultados recibidos:', data);
        showNotification('Ronda finalizada. Mostrando resultados...', 'success');
        addResultStyles(); // Asegurarse de que los estilos existan

        // Ocultar el mensaje de turno si existe
        const turnDisplay = document.getElementById('turnDisplay');
        if (turnDisplay) turnDisplay.style.display = 'none';

        data.results.forEach(result => {
            const playerDiv = document.querySelector(`.player-position[data-player-id="${result.playerId}"]`);
            if (playerDiv) {
                // Crear un div para el resultado
                const resultOverlay = document.createElement('div');
                resultOverlay.className = `result-overlay result-${result.outcome.toLowerCase()}`;
                
                resultOverlay.innerHTML = `
                    <div class="outcome-text">${result.outcome}</div>
                    <div class="score-text">Puntos: ${result.playerScore}</div>
                `;
                
                playerDiv.appendChild(resultOverlay);

                // Actualizar el balance en la vista del dealer
                const balanceDisplay = playerDiv.querySelector('.player-balance');
                if (balanceDisplay) {
                    balanceDisplay.textContent = `Balance: $${result.newBalance}`;
                }
            }
        });

        // Mostrar la puntuación final del dealer
        const dealerHandContainer = document.getElementById('dealerCards');
        // Remover score display anterior si existe
        const oldScoreDisplay = dealerHandContainer.querySelector('.dealer-score-display');
        if (oldScoreDisplay) oldScoreDisplay.remove();

        const dealerScoreDisplay = document.createElement('div');
        dealerScoreDisplay.className = 'dealer-score-display';
        let dealerText = `Puntuación del Dealer: ${data.dealerScore}`;
        if (data.dealerScore > 21) {
            dealerText += ' (BUST)';
        } else if (data.dealerScore === 21 && document.getElementById('dealerCards').querySelectorAll('.card').length === 2) {
            dealerText += ' (BLACKJACK)';
        }
        dealerScoreDisplay.textContent = dealerText;
        dealerHandContainer.appendChild(dealerScoreDisplay);
    });

    // Errores
    socket.on('error', (data) => {
        console.error('❌ Error del servidor:', data);
        showNotification('Error: ' + data.message, 'error');
    });

    // Desconexión
    socket.on('disconnect', () => {
        console.log('❌ Desconectado del servidor');
        showNotification('Desconectado del servidor', 'error');
    });

    // Juego reiniciado
    socket.on('gameReset', () => {
        console.log('🔄 Juego reiniciado por el servidor.');
        showNotification('El juego ha sido reiniciado.', 'info');
        // Limpiar manos y highlights
        document.getElementById('dealerCards').innerHTML = '';
        document.querySelectorAll('.player-cards-hand').forEach(hand => hand.innerHTML = '');
        document.querySelectorAll('.player-position').forEach(div => {
            div.classList.remove('current-turn');
            div.classList.remove('busted');
            // Remover overlays de resultados
            const overlay = div.querySelector('.result-overlay');
            if (overlay) overlay.remove();
        });
        document.getElementById('revealCardBtn').style.display = 'none';
        // Remover puntuación del dealer
        const dealerScore = document.querySelector('.dealer-score-display');
        if (dealerScore) dealerScore.remove();
        stopBettingTimer();
    });

    // Eventos adicionales que podrían estar faltando
    socket.on('reconnect', () => {
        console.log('🔄 Reconectado al servidor');
        showNotification('Reconectado', 'success');
        // Volver a unirse a la sala
        if (roomCode) {
            socket.emit('joinRoom', roomCode);
        }
    });
}

// === FUNCIONES DE RENDERIZADO ===

function renderPlayers(players) {
    const playerCardsContainer = document.getElementById('playerCards');
    
    if (players.length === 0) {
        playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
        return;
    }

    playerCardsContainer.innerHTML = '';

    players.forEach((player, index) => {
        const playerDiv = document.createElement('div');
        playerDiv.className = 'player-position';
        playerDiv.dataset.playerId = player.id;

        let betDisplay = '';
        let floatingBetHtml = '';

        if (player.betConfirmed && player.bet > 0) {
            floatingBetHtml = `<div class="confirmed-bet-floater">$${player.bet}</div>`;
            betDisplay = `
                <div class="bet-confirmed-icon">
                    <i class="fas fa-check-circle"></i> 
                    <span>Confirmado</span>
                </div>`;
        } else if (player.bet > 0) {
            betDisplay = `<div class="bet-pending">$${player.bet} (Esperando)</div>`;
        } else {
            betDisplay = `<div class="no-bet">Sin apuesta</div>`;
        }

        playerDiv.innerHTML = `
            <div class="player-header">
                <div class="player-name-display">${player.name}</div>
                <div class="player-balance">$${player.balance || 100}</div>
            </div>
            <div class="player-cards-hand">
                <div class="card-slot">Esperando cartas...</div>
            </div>
            <div class="player-bet">${betDisplay}</div>
            ${floatingBetHtml}`;

        playerCardsContainer.appendChild(playerDiv);
    });
}

function addPlayerStyles() {
    if (document.getElementById('dealer-player-styles')) return;
    const style = document.createElement('style');
    style.id = 'dealer-player-styles';
    style.innerHTML = `
        .player-position.busted {
            background: rgba(192, 57, 43, 0.4);
            border-color: #e74c3c;
            opacity: 0.8;
        }
        .player-position.busted::after {
            content: 'BUST';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 2.5em; font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 2px 2px 5px #000;
            pointer-events: none;
        }`;
    document.head.appendChild(style);
}

function addResultStyles() {
    if (document.getElementById('game-result-styles')) return;
    const style = document.createElement('style');
    style.id = 'game-result-styles';
    style.innerHTML = `
        .result-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 15;
            text-align: center;
            animation: fadeIn 0.5s;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .result-overlay .outcome-text {
            font-size: 2.5em;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 2px 2px 5px #000;
        }
        .result-overlay .score-text {
            font-size: 1.2em;
            margin-top: 5px;
        }
        .result-overlay.result-win, .result-overlay.result-blackjack { background: rgba(39, 174, 96, 0.7); }
        .result-overlay.result-lose { background: rgba(192, 57, 43, 0.7); }
        .result-overlay.result-push { background: rgba(44, 62, 80, 0.7); }
        .dealer-score-display {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #FFD700;
            padding: 5px 15px;
            border-radius: 10px;
            font-weight: bold;
            white-space: nowrap;
        }`;
    document.head.appendChild(style);
}

// === FUNCIONES DE CONTROL ===

function highlightCurrentPlayer(playerId) {
    // Remover highlight de todos los jugadores primero
    document.querySelectorAll('.player-position').forEach(div => {
        div.classList.remove('current-turn');
    });

    if (!playerId) {
        // Si no hay ID de jugador, es el turno del dealer o un estado intermedio.
        return;
    }

    // Agregar highlight al jugador actual
    const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
    if (playerDiv) {
        playerDiv.classList.add('current-turn');
    }
}

function updateGameStatus() {
    const playersCount = playersList.length;
    const confirmedCount = playersList.filter(p => p.betConfirmed).length;

    document.getElementById('contador').textContent = playersCount;
    document.getElementById('playersCount').textContent = playersCount;
    document.getElementById('confirmedCount').textContent = `${confirmedCount}/${playersCount}`;

    updateControlButtons();
    addPlayerStyles(); // Asegurarse de que los estilos de 'busted' existan
}

function updateGameStateDisplay() {
    const display = document.getElementById('gameStateDisplay');
    display.className = `game-state-${gameState}`;
    
    const stateNames = {
        waiting: 'Esperando',
        betting: 'Apostando',
        playing: 'Jugando',
        finished: 'Finalizado'
    };
    
    display.textContent = stateNames[gameState] || gameState;
}

function updateControlButtons() {
    const startBettingBtn = document.getElementById('startBettingBtn');
    const dealCardsBtn = document.getElementById('dealCardsBtn');
    
    console.log(`Actualizando botones - Estado: ${gameState}, Jugadores: ${playersList.length}`);
    
    // Botón iniciar apuestas
    if (gameState === 'waiting' && playersList.length > 0) {
        startBettingBtn.disabled = false;
        startBettingBtn.innerHTML = '<i class="fas fa-play"></i> INICIAR APUESTAS';
        startBettingBtn.style.opacity = '1';
    } else if (gameState === 'betting') {
        startBettingBtn.disabled = true;
        startBettingBtn.innerHTML = '<i class="fas fa-clock"></i> APOSTANDO...';
        startBettingBtn.style.opacity = '0.6';
    } else {
        startBettingBtn.disabled = true;
        startBettingBtn.innerHTML = '<i class="fas fa-play"></i> INICIAR APUESTAS';
        startBettingBtn.style.opacity = '0.6';
    }
    
    // Botón repartir cartas
    const allConfirmed = playersList.length > 0 && playersList.every(p => p.betConfirmed);
    const dealerHasCards = document.getElementById('dealerCards').children.length > 0;
    
    if (gameState === 'playing' && allConfirmed && !dealerHasCards) {
        dealCardsBtn.disabled = false;
        dealCardsBtn.style.opacity = '1';
    } else {
        dealCardsBtn.disabled = true;
        dealCardsBtn.style.opacity = '0.6';
    }
}

function revealDealerCardAction() {
    console.log('-> Emitiendo dealerRevealCard');
    socket.emit('dealerRevealCard');
    document.getElementById('revealCardBtn').style.display = 'none'; // Ocultar inmediatamente
}

// === FUNCIONES DE TIMER ===

function startBettingTimer(duration) {
    const timerElement = document.getElementById('bettingTimer');
    const displayElement = document.getElementById('timerDisplay');
    const progressElement = document.getElementById('timerProgress');
    
    timerElement.style.display = 'block';
    let timeLeft = duration;
    
    // Actualización inicial
    const seconds = Math.ceil(timeLeft / 1000);
    displayElement.textContent = `${seconds}s`;
    progressElement.style.width = '100%';
    
    bettingTimer = setInterval(() => {
        timeLeft -= 1000;
        
        const seconds = Math.ceil(timeLeft / 1000);
        displayElement.textContent = `${seconds}s`;
        
        const progressPercent = Math.max(0, (timeLeft / duration) * 100);
        progressElement.style.width = `${progressPercent}%`;
        
        // Cambiar color cuando quedan pocos segundos
        if (seconds <= 10) {
            displayElement.style.color = '#ff4757';
            progressElement.style.background = 'linear-gradient(90deg, #ff4757, #ff6b6b)';
        }
        
        if (timeLeft <= 0) {
            stopBettingTimer();
        }
    }, 1000);
}

function stopBettingTimer() {
    if (bettingTimer) {
        clearInterval(bettingTimer);
        bettingTimer = null;
    }
    
    const timerElement = document.getElementById('bettingTimer');
    const displayElement = document.getElementById('timerDisplay');
    const progressElement = document.getElementById('timerProgress');
    
    timerElement.style.display = 'none';
    
    // Resetear estilos
    displayElement.style.color = '#ff6b6b';
    progressElement.style.background = 'linear-gradient(90deg, #ff6b6b, #ffa500)';
}

// === FUNCIONES DE CONTROL DEL JUEGO ===

function startBetting() {
    console.log('🎯 Iniciando período de apuestas...');
    
    if (playersList.length === 0) {
        showNotification('No hay jugadores en la sala', 'warning');
        return;
    }
    
    if (gameState !== 'waiting') {
        showNotification('No se puede iniciar apuestas en este momento', 'warning');
        return;
    }
    
    const duration = 30000; // 30 segundos
    console.log('📡 Emitiendo evento startBetting con duración:', duration);
    
    // Deshabilitar botón inmediatamente para evitar múltiples clics
    const startBettingBtn = document.getElementById('startBettingBtn');
    startBettingBtn.disabled = true;
    startBettingBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> INICIANDO...';
    
    socket.emit('startBetting', duration);
    
    // Feedback visual inmediato
    showNotification('Iniciando período de apuestas...', 'info');
}

function dealCards() {
    console.log('🎰 Repartiendo cartas...');
    
    const allConfirmed = playersList.every(p => p.betConfirmed);
    if (!allConfirmed || playersList.length === 0) {
        showNotification('No todos los jugadores han confirmado sus apuestas', 'warning');
        return;
    }
    
    // Deshabilitar botón para evitar clics múltiples
    document.getElementById('dealCardsBtn').disabled = true;
    
    // Emitir evento al servidor para que reparta las cartas
    socket.emit('dealCards');
}

function resetGame() {
    if (confirm('¿Seguro que quieres reiniciar el juego? Esto limpiará todas las apuestas.')) {
        console.log('🔄 Reiniciando juego...');
        
        socket.emit('resetGame');
        showNotification('Reiniciando juego...', 'info');
        
        // Limpiar timer si está activo
        stopBettingTimer();
        
        // Resetear estado local
        gameState = 'waiting';
        updateGameStateDisplay();
        updateControlButtons();
    }
}

// === LÓGICA DE ANIMACIÓN DE CARTAS ===

socket.on('cardsDealt', (data) => {
    console.log('🃏 Recibiendo cartas del servidor:', data);
    
    // Limpiar manos actuales antes de repartir
    document.getElementById('dealerCards').innerHTML = '';
    document.querySelectorAll('.player-cards-hand').forEach(hand => {
        hand.innerHTML = '';
    });

        // Aunque el dealer conoce su mano completa (data.dealer), para la animación
    // inicial, debemos mostrar la segunda carta como oculta, igual que los jugadores.
    // La mano real se guarda en el servidor.
    const dealerHandForDisplay = [
        data.dealer[0],  // La primera carta, visible
        { hidden: true } // La segunda carta, la mostramos oculta
    ];
    animateDealing(data.players, dealerHandForDisplay);
});

function createCardElement(card) {
    const cardDiv = document.createElement('div');
    
    if (card.hidden) {
        cardDiv.className = 'card card-back';
        return cardDiv;
    }

    // Usar la imagen de la carta como fondo
    cardDiv.className = 'card';
    cardDiv.style.backgroundImage = `url('/${card.src}')`;
    // Opcional: puedes dejar el texto superpuesto si tu CSS lo permite
    return cardDiv;
}

async function animateDealing(players, dealerHand) {
    const deckElement = document.querySelector('.deck-pile');
    if (!deckElement) return;

    const deckRect = deckElement.getBoundingClientRect();
    const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

    const dealSequence = [];

    // Ronda 1: Jugadores -> Dealer
    playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] }));
    dealSequence.push({ target: 'dealer', card: dealerHand[0] });

    // Ronda 2: Jugadores -> Dealer
    playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] }));
    dealSequence.push({ target: 'dealer', card: dealerHand[1] });

    for (const deal of dealSequence) {
        await dealOneCard(deal, deckRect);
    }

    // CORRECCIÓN: Después de la animación, el dealer debe renderizar su mano real.
    // La animación muestra la segunda carta como oculta, pero el dealer ya conoce su valor.
    // Aquí sincronizamos la vista con los datos reales que recibió.
    const dealerHandContainer = document.getElementById('dealerCards');
    dealerHandContainer.innerHTML = ''; // Limpiar la mano animada

    dealerHand.forEach(cardData => {
        const cardElement = createCardElement(cardData);
        cardElement.style.position = 'absolute';
        dealerHandContainer.appendChild(cardElement);
    });

    // Aplicar el efecto abanico a la mano real y final.
    applyFanEffect(); 
}

function dealOneCard(deal, deckRect) {
    return new Promise(resolve => {
        let targetHandElement;
        if (deal.target === 'player') {
            targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
        } else {
            targetHandElement = document.getElementById('dealerCards');
        }

        if (!targetHandElement) {
            console.warn(`No se encontró el contenedor de mano para ${deal.target} ${deal.id || ''}`);
            return resolve();
        }

        const cardElement = createCardElement(deal.card);
        cardElement.classList.add('dealing-animation');
        cardElement.style.left = `${deckRect.left}px`;
        cardElement.style.top = `${deckRect.top}px`;

        document.body.appendChild(cardElement);

        const targetRect = targetHandElement.getBoundingClientRect();
        // Apuntar la animación al centro del contenedor de la mano para un aterrizaje suave.
        // Restamos la mitad del ancho/alto de la carta para centrarla.
        const cardWidth = 80;
        const cardHeight = 120;
        const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
        const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

        // Pequeño delay para que la transición se aplique correctamente
        setTimeout(() => {
            cardElement.style.transform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;
            
            cardElement.addEventListener('transitionend', () => {
                cardElement.remove(); // Eliminar la carta animada
                const finalCard = createCardElement(deal.card);
                finalCard.style.position = 'absolute'; // Aseguramos que la carta final se pueda posicionar
                targetHandElement.appendChild(finalCard); // Añadir la carta final estática
                applyFanEffect(); // Re-aplicar el abanico en cada carta para un efecto progresivo
                resolve();
            }, { once: true });
        }, 50);
    });
}

// === FUNCIONES AUXILIARES ===

function applyFanEffect() {
    const hands = document.querySelectorAll('.player-cards-hand, .dealer-hand');

    hands.forEach(hand => {
        // Asegurarse de que el contenedor de la mano tenga posición relativa
        hand.style.position = 'relative';
        // Y una altura mínima para que no colapse si solo tiene elementos absolutos
        if (hand.querySelectorAll('.card').length > 0) {
            hand.style.minHeight = '120px'; // Altura aprox. de una carta
        } else {
            hand.style.minHeight = 'auto'; // Resetear si no hay cartas
        }

        const cards = hand.querySelectorAll('.card');
        const total = cards.length;
        if (total === 0) return;

        const maxAngle = 20; // Ángulo máximo de rotación
        const horizontalSpread = 30; // Píxeles de separación entre cartas
        const totalWidth = (total - 1) * horizontalSpread;

        cards.forEach((card, index) => {
            const pivotIndex = (total - 1) / 2;
            let angle = 0;
            // Evitar división por cero si solo hay una carta
            if (total > 1 && pivotIndex > 0) {
                angle = (index - pivotIndex) * (maxAngle / pivotIndex);
            }
            const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);
            
            // Posicionar cada carta desde el centro del contenedor
            card.style.left = '50%';
            // El transform ahora incluye un ajuste para centrar la propia carta (-50% de su ancho)
            // y luego aplica el desplazamiento para el efecto abanico.
            card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
        });
    });
}

function copyRoomCode() {
    if (roomCode) {
        navigator.clipboard.writeText(roomCode)
            .then(() => {
                showNotification('¡Código copiado al portapapeles!', 'success');
            })
            .catch(err => {
                console.error('Error al copiar:', err);
                // Fallback para navegadores que no soportan clipboard API
                const textArea = document.createElement('textarea');
                textArea.value = roomCode;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    showNotification('¡Código copiado al portapapeles!', 'success');
                } catch (fallbackErr) {
                    showNotification('Error al copiar código', 'error');
                }
                document.body.removeChild(textArea);
            });
    }
}

function showNotification(message, type = 'info') {
    // Remover notificaciones existentes
    const existingNotifications = document.querySelectorAll('.notification');
    existingNotifications.forEach(notification => notification.remove());
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);

    // Auto-remover después de 4 segundos
    setTimeout(() => {
        if (notification.parentNode) {
            notification.remove();
        }
    }, 4000);
    
    console.log(`📢 Notificación [${type.toUpperCase()}]: ${message}`);
}

// Función para salir de la sala 
async function exitRoom() {
    if (confirm('¿Seguro que quieres cerrar la sala? Esto desconectará a todos los jugadores.')) {
        try {
            showNotification('Cerrando sala...', 'info');
            
            // Intentar cerrar la sala en el servidor
            const response = await fetch('/salir-mesa', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ codigo: roomCode })
            });
            
            if (response.ok) {
                showNotification('Sala cerrada exitosamente', 'success');
                setTimeout(() => {
                    window.location.href = '/';
                }, 1500);
            } else {
                throw new Error('Error en el servidor');
            }
        } catch (error) {
            console.error('Error al salir de la mesa:', error);
            showNotification('Error al cerrar la sala. Redirigiendo...', 'warning');
            
            // Redirigir de todos modos después de un breve delay
            setTimeout(() => {
                window.location.href = '/';
            }, 2000);
        }
    }
}

// === MANEJO DE ERRORES Y RECONEXIÓN ===

// Manejar errores de conexión
socket.on('connect_error', (error) => {
    console.error('❌ Error de conexión:', error);
    showNotification('Error de conexión al servidor', 'error');
});

// Manejar intentos de reconexión
socket.on('reconnect_attempt', (attemptNumber) => {
    console.log(`🔄 Intento de reconexión #${attemptNumber}`);
    showNotification(`Reconectando... (${attemptNumber})`, 'info');
});

// Manejar reconexión exitosa
socket.on('reconnect', (attemptNumber) => {
    console.log(`✅ Reconectado después de ${attemptNumber} intentos`);
    showNotification('Reconectado al servidor', 'success');
    
    // Volver a unirse a la sala
    if (roomCode) {
        socket.emit('joinRoom', roomCode);
    }
});

// === DEBUG Y DESARROLLO ===

// Función de debug para inspeccionar el estado
function debugState() {
    console.log('=== ESTADO ACTUAL ===');
    console.log('roomCode:', roomCode);
    console.log('gameState:', gameState);
    console.log('playersList:', playersList);
    console.log('socket.id:', socket.id);
    console.log('socket.connected:', socket.connected);
    console.log('===================');
}

// Hacer función debug disponible globalmente para testing
window.debugState = debugState;

// Logs adicionales para debugging
console.log('🔧 Script del dealer cargado exitosamente');
console.log('📋 Funciones disponibles globalmente: debugState()');
    </script>
<body>
</html>