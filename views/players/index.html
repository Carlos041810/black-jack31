<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="/css/header.css">
    <link rel="stylesheet" href="/css/players.css">
</head>

<body>

    <!-- El header reutilizable se insertará aquí desde el servidor -->



    <!-- ÁREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- ÁREA DEL DEALER (ARRIBA) -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>
            <div class="dealer-hand" id="dealerCards">
                <!-- Las cartas del dealer se renderizarán aquí -->
            </div>
        </div>

        <!-- SVG DECORATIVO (CENTRO) -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <!-- Curvas alineadas -->
                    <path id="curve-top" d="M 150 150 Q 500 220 850 150" />
                    <path id="curve-bottom" d="M 150 200 Q 500 270 850 200" />
                    <path id="curve-middle" d="M 130 208 Q 500 278 870 208" />

                    <!-- Efectos de sombra -->
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>

                <!-- Línea decorativa visible que sigue la curva del texto -->
                <use href="#curve-middle" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />

                <!-- Texto superior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK 31 PAYS 3 TO 2
                    </textPath>
                </text>

                <!-- Texto inferior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 27 AND DRAW TO 26
                    </textPath>
                </text>
            </svg>
        </div>
        <!-- ÁREA DEL JUGADOR (ABAJO) -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <!-- Los jugadores se renderizarán aquí dinámicamente -->
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>
    </div>

    <!-- ÁREA DE APUESTAS -->
    <div class="betting-area" id="bettingArea" style="display: none;">
        <div class="betting-modal-content">
            <div class="betting-info-header">
                <div class="balance-info">Balance<br><span id="balance">$100</span></div>
                <div>Total Bet<br><span id="totalBet">$0</span></div>
            </div>
            <div class="chips">
                <div class="chip chip-10" onclick="placeBet(10)">$10</div>
                <div class="chip chip-25" onclick="placeBet(25)">$25</div>
                <div class="chip chip-50" onclick="placeBet(50)">$50</div>
                <div class="chip chip-100" onclick="placeBet(100)">$100</div>
            </div>
            <div class="betting-buttons">
                <button onclick="clearBet()">CLEAR</button>
                <button id="confirmBetBtn" onclick="confirmBet()">CONFIRM BET</button>
            </div>
        </div>
    </div>

    <!-- ÁREA DE ACCIONES DEL JUGADOR -->
    <div class="player-actions" id="playerActions" style="display: none;">
        <button id="hitBtn" class="action-btn hit">Pedir</button>
        <button id="standBtn" class="action-btn stand">Plantarse</button>
    </div>

    <!-- Modal de Fin de Ronda -->
    <div id="endRoundModal" class="end-round-modal" style="display: none;">
        <div class="end-round-modal-content">
            <span class="close-button" onclick="document.getElementById('endRoundModal').style.display='none'">&times;</span>
            <h2 id="endRoundModalTitle">Ronda Finalizada</h2>
            <div id="endRoundModalBody">
                <p>Esperando que el dealer inicie la siguiente ronda.</p>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/header.js"></script>
    <script>
        // Variables globales
        window.socket = io();
        let currentBalance = 100; 
        let currentBet = 0;
        let betConfirmed = false;
        let gameState = 'waiting';
        let currentPlayerName = '';
        let playersList = []; // Lista de jugadores para referencia
        let roomCode = '';

        const balanceEl = document.getElementById('balance');
        const totalBetEl = document.getElementById('totalBet');
        const bettingArea = document.getElementById('bettingArea');

        document.addEventListener('DOMContentLoaded', () => {
            const params = new URLSearchParams(window.location.search);
            roomCode = params.get('codigo');
            currentPlayerName = params.get('nombre');

            // Unirse a la sala
            if (roomCode && window.socket) {
                window.socket.emit('joinRoom', roomCode, currentPlayerName);
                setupRoomCodeDisplay();
            }

            // === EVENT LISTENERS PARA ACCIONES ===
            document.getElementById('hitBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerHit');
                window.socket.emit('playerHit');
            });

            document.getElementById('standBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerStand');
                window.socket.emit('playerStand');
            });

            // === EVENTOS DEL SERVIDOR ===

            // Lista de jugadores actualizada
            window.socket.on('updatePlayerList', (players) => {
                console.log('Lista de jugadores actualizada:', players);
                playersList = players; // Guardar la lista globalmente
                renderPlayers(players, currentPlayerName);
                document.getElementById('contador').textContent = players.length;

                // Actualizar nuestro balance si existe en la lista
                const currentPlayer = players.find(p => p.name === currentPlayerName);
                if (currentPlayer) {
                    // El balance puede ser 0, lo cual es un valor válido. No usar '||' para fallback.
                    currentBalance = (currentPlayer.balance !== null && currentPlayer.balance !== undefined) ? currentPlayer.balance : 100;
                    currentBet = currentPlayer.bet || 0;
                    betConfirmed = currentPlayer.betConfirmed || false;
                    updateBetDisplay();
                    updateBettingControls();
                }
            });

            // Estado del juego actualizado
            window.socket.on('gameStateUpdate', (data) => {
                gameState = data.state;
                console.log('Estado del juego:', gameState);
                
                // Mostrar/ocultar área de apuestas según el estado
                    if (gameState === 'betting') {
                    bettingArea.style.display = 'flex';
                } else {
                    bettingArea.style.display = 'none';
                }

                updateBettingControls();
            });

            // Apuestas cerradas
            window.socket.on('bettingClosed', () => {
                console.log('Período de apuestas cerrado');
                disableAllBettingControls();
            });

            // Jugador confirmó apuesta
            window.socket.on('playerBetConfirmed', (data) => {
                console.log(`${data.playerName} confirmó apuesta de $${data.bet}`);
                showNotification(`${data.playerName} confirmó apuesta de $${data.bet}`);
            });

            // Iniciar juego
            window.socket.on('startGame', () => {
                console.log('¡Juego iniciado! Todos los jugadores confirmaron sus apuestas');
                showNotification('¡Juego iniciado! Repartiendo cartas...');
                bettingArea.style.display = 'none';
            });

            // Errores de apuesta
            window.socket.on('betError', (data) => {
                alert('Error en apuesta: ' + data.errors.join(', '));
            });

            // Apuesta actualizada
            window.socket.on('betUpdated', (data) => {
                console.log('Apuesta actualizada a:', data.bet);
            });

            // Apuesta cancelada
            window.socket.on('betCancelled', () => {
                console.log('Apuesta cancelada');
                currentBet = 0;
                updateBetDisplay();
            });

            window.socket.on('turnUpdate', (data) => {
                console.log(`[TURN] Turno de: ${data.playerName}`);
                highlightCurrentPlayerUI(data.playerId, data.playerName);
            });

            window.socket.on('gameReset', () => {
                console.log('🔄 Juego reiniciado.');
                showNotification('El juego ha sido reiniciado.');
                // Limpiar la mano del dealer
                document.getElementById('dealerCards').innerHTML = '';
                // Limpiar el mensaje de turno. El resto de la UI se limpia con 'updatePlayerList'
                document.getElementById('playerActions').style.display = 'none';
                const turnDisplay = document.getElementById('turnDisplay');
                // Limpiar overlays de resultados
                document.querySelectorAll('.result-overlay').forEach(o => o.remove());
                // Limpiar clases de resultado de las cartas
                document.querySelectorAll('.card-lost').forEach(c => {
                    c.classList.remove('card-lost');
                });
                // Limpiar bordes de estado (bust/stand)
                document.querySelectorAll('.busted-card').forEach(c => c.classList.remove('busted-card'));
                document.querySelectorAll('.stood-card').forEach(c => c.classList.remove('stood-card'));
                document.querySelectorAll('.busted').forEach(b => b.classList.remove('busted'));
                // Limpiar bordes de resultado de la ronda anterior
                document.querySelectorAll('.card-win-border, .card-lose-border').forEach(c => {
                    c.classList.remove('card-win-border', 'card-lose-border');
                });
                const dealerScore = document.querySelector('.dealer-score-display');
                if (dealerScore) dealerScore.remove();
                if (turnDisplay) turnDisplay.remove();
            });

            // Errores generales
            window.socket.on('error', (data) => {
                alert('Error: ' + data.message);
            });

            window.socket.on('cardsDealt', (data) => {
                console.log('🃏 Recibiendo cartas del servidor:', data);
                
                // Limpiar manos actuales antes de repartir
                document.getElementById('dealerCards').innerHTML = '';
                document.querySelectorAll('.player-cards-hand').forEach(hand => {
                    hand.innerHTML = '';
                });

                // Ocultar área de apuestas y deshabilitar controles
                bettingArea.style.display = 'none';
                // Ocultar botones de acción al repartir, se mostrarán cuando sea el turno
                document.getElementById('playerActions').style.display = 'none';
                animateDealing(data.players, data.dealer);
            });
            
            // Un jugador (o yo) recibe una nueva carta
            window.socket.on('playerCardUpdate', (data) => {
                console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);
                
                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'player',
                    id: data.playerId,
                    card: data.newCard,
                };
                // Animar solo la nueva carta que se reparte
                dealOneCard(dealInfo, deckRect);
            });

            // Un jugador se pasa de 21
            window.socket.on('playerBust', (data) => {
                console.log(`[BUST] ${data.playerName} se ha pasado.`);
                showNotification(`${data.playerName} se pasó con ${data.score}!`, 'error');
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    const cardsInHand = playerDiv.querySelectorAll('.player-cards-hand .card');
                    cardsInHand.forEach(card => {
                        card.classList.add('busted-card');
                    });
                    // Actualizar el display de información del jugador
                    const infoDisplay = playerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `<strong>${data.playerName}</strong> se pasó de 31`;
                        infoDisplay.classList.add('status-bust');
                    }
                }
                // Si soy yo quien se ha pasado, oculto mis botones de acción.
                if (data.playerId === window.socket.id) {
                    document.getElementById('playerActions').style.display = 'none';
                }
            });

            // Un jugador se planta
            window.socket.on('playerStood', (data) => {
                console.log(`[STAND] ${data.playerName}   se ha plantado.`);
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    // Añadir un borde de color a las cartas para indicar que se ha plantado
                    const cardsInHand = playerDiv.querySelectorAll('.player-cards-hand .card');
                    cardsInHand.forEach(card => {
                        card.classList.add('stood-card'); // La clase correcta es 'stood-card'
                    });

                    const infoDisplay = playerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `<strong>${data.playerName}</strong> se plantó`;
                        infoDisplay.classList.add('status-stand');
                    }
                }
            });

            // El turno pasa al dealer
            window.socket.on('dealerTurn', () => {
                console.log('[DEALER TURN] Turno del dealer.');
                showNotification('Turno del Dealer. Revelando carta...', 'info');
                // Des-resaltar a todos y mostrar mensaje del dealer
                // El null en playerId se encarga de que no se resalte a nadie
                // y el mensaje se actualice correctamente.
                highlightCurrentPlayerUI(null, 'Dealer');
            });

            // El dealer revela su carta
            window.socket.on('revealDealerCard', (data) => {
                console.log('[DEALER REVEAL] El dealer revela su mano completa:', data.dealerHand);
                const dealerHandContainer = document.getElementById('dealerCards');
                
                // Limpiar la mano actual del dealer (que contiene cartas ocultas)
                dealerHandContainer.innerHTML = '';

                // Renderizar la mano completa del dealer con todas las cartas visibles
                data.dealerHand.forEach(cardData => {
                    const cardElement = createCardElement(cardData);
                    cardElement.style.position = 'absolute'; // Necesario para el efecto abanico
                    dealerHandContainer.appendChild(cardElement);
                });
                
                applyFanEffect(); // Re-aplicar el efecto abanico para ajustar las posiciones
            });

            // El dealer pide una carta (Hit)
            window.socket.on('dealerCardUpdate', (data) => {
                console.log(`[DEALER HIT] Dealer recibe una carta.`);
                
                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'dealer',
                    card: data.newCard,
                };
                // Animar la carta que pide el dealer
                dealOneCard(dealInfo, deckRect);
            });

            // Resultados del juego
            window.socket.on('gameResults', (data) => {
                console.log('[RESULTS] Resultados recibidos:', data);
                showNotification('Ronda finalizada. Mostrando resultados...', 'success');
                addResultStyles(); // Asegurarse de que los estilos existan

                // Ocultar el mensaje de turno y los botones de acción
                const turnDisplay = document.getElementById('turnDisplay');
                if (turnDisplay) turnDisplay.style.display = 'none';
                document.getElementById('playerActions').style.display = 'none';

                data.results.forEach(result => {
                    // Lógica para colorear bordes de cartas del jugador y dealer
                    if (result.playerId === window.socket.id) {
                        const playerWin = result.outcome === 'WIN' || result.outcome === 'BLACKJACK';
                        const playerLose = result.outcome === 'LOSE';

                        const myPlayerDiv = document.querySelector(`.player-position[data-player-id="${window.socket.id}"]`);
                        const dealerHandContainer = document.getElementById('dealerCards');

                        if (myPlayerDiv && dealerHandContainer) {
                            const myCards = myPlayerDiv.querySelectorAll('.player-cards-hand .card');
                            const dealerCards = dealerHandContainer.querySelectorAll('.card');

                            if (playerWin) {
                                myCards.forEach(c => c.classList.add('card-win-border'));
                                dealerCards.forEach(c => c.classList.add('card-lose-border'));
                            } else if (playerLose) {
                                myCards.forEach(c => c.classList.add('card-lose-border'));
                                dealerCards.forEach(c => c.classList.add('card-win-border'));
                            }
                            // No se aplica borde especial en caso de PUSH (empate)
                        }
                    }



                    const playerDiv = document.querySelector(`.player-position[data-player-id="${result.playerId}"]`);
                    if (playerDiv) {
                        // Se ha eliminado la creación del overlay de resultado (WIN/PUSH/etc.)

                        // Actualizar nuestro propio balance
                        if (result.playerId === window.socket.id) {
                            currentBalance = result.newBalance;
                            updateBetDisplay();
                        }
                    }
                });

                // Mostrar la puntuación final del dealer
                const dealerHandContainer = document.getElementById('dealerCards');
                // Remover score display anterior si existe
                const oldScoreDisplay = dealerHandContainer.querySelector('.dealer-score-display');
                if (oldScoreDisplay) oldScoreDisplay.remove();

                const dealerScoreDisplay = document.createElement('div');
                dealerScoreDisplay.className = 'dealer-score-display';
                let dealerText = `Puntuación del Dealer: ${data.dealerScore}`;
                if (data.dealerScore > 31) {
                    dealerText += ' (BUST)';
                } else if (data.dealerScore === 31 && document.getElementById('dealerCards').querySelectorAll('.card').length === 2) {
                    dealerText += ' (BLACKJACK)';
                }
                dealerScoreDisplay.textContent = dealerText;
                dealerHandContainer.appendChild(dealerScoreDisplay);

                // Abrir el modal de fin de ronda después de 3 segundos
                 setTimeout(() => {
                    const modal = document.getElementById('endRoundModal');
                    const modalBody = document.getElementById('endRoundModalBody');
                    
                    // 1. Ordenar los resultados
                    const sortedResults = [...data.results].sort((a, b) => {
                        const scoreA = a.playerScore;
                        const scoreB = b.playerScore;
                        const aBusted = scoreA > 31;
                        const bBusted = scoreB > 31;

                        if (aBusted && !bBusted) return 1; // 'a' se pasó, va después
                        if (!aBusted && bBusted) return -1; // 'b' se pasó, va después
                        if (aBusted && bBusted) return scoreA - scoreB; // Ambos se pasaron, el que menos se pasó va primero
                        return scoreB - scoreA; // Ninguno se pasó, el más alto va primero
                    });

                    // 2. Crear el HTML para la lista de puntuaciones
                    let resultsHtml = `
                        <div class="results-list">
                            <div class="results-header">
                                <span>Jugador</span>
                                <span>Puntuación</span>
                            </div>
                    `;
                    sortedResults.forEach(result => {
                        resultsHtml += `
                            <div class="results-row">
                                <span>${result.playerName}</span>
                                <span>${result.playerScore > 31 ? `Se pasó (${result.playerScore})` : result.playerScore}</span>
                            </div>
                        `;
                    });
                    resultsHtml += '</div><p class="waiting-next-round">Esperando que el dealer inicie la siguiente ronda...</p>';

                    // 3. Actualizar el contenido del modal y mostrarlo
                    if (modal && modalBody) {
                        modalBody.innerHTML = resultsHtml;
                        modal.style.display = 'flex';
                    }
                }, 4000); // Aumentado a 4s para dar tiempo a ver los resultados en mesa
            });
        });

        // === FUNCIONES DE RENDERIZADO ===

        function setupRoomCodeDisplay() {
            const mobileRoomCodeText = document.getElementById('mobileRoomCodeText');
            if (mobileRoomCodeText) {
                mobileRoomCodeText.textContent = `${roomCode}`;
            }
        }

        function renderPlayers(players, currentPlayerName) {
            const playerCardsContainer = document.getElementById('playerCards');
            playerCardsContainer.innerHTML = '';

            if (players.length === 0) {
                playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
                return;
            }

            // Añadir clase específica para un solo jugador
            if (players.length === 1) {
                playerCardsContainer.classList.add('single-player-layout');
            } else {
                playerCardsContainer.classList.remove('single-player-layout');
            }

            if (players.length === 2) {
                // Caso especial para 2 jugadores: apilados y centrados con Flexbox
                playerCardsContainer.classList.add('two-players');

                const currentPlayer = players.find(p => p.name === currentPlayerName);
                const otherPlayer = players.find(p => p.name !== currentPlayerName);

                // Renderizar al otro jugador primero (arriba), luego al jugador actual (abajo)
                [otherPlayer, currentPlayer].forEach((player) => {
                    if (!player) return;

                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-position'; // Sin clases de posicionamiento absoluto
                    playerDiv.dataset.playerId = player.id;

                    let betDisplay = '';
                    let betStatusClass = '';

                    if (player.betConfirmed && player.bet > 0) {
                        betDisplay = `<div class="bet-confirmed-icon">${player.bet}</div>`;
                        betStatusClass = 'bet-confirmed';
                    } else if (player.bet > 0) {
                        betDisplay = `<div class="bet-pending">${player.bet} (Pendiente)</div>`;
                        betStatusClass = 'bet-pending';
                    } else {
                        betDisplay = ``;
                        betStatusClass = 'no-bet';
                    }

                    playerDiv.innerHTML = `
                        <div class="player-content">
                            <div class="player-info-display">${player.name}</div>
                            <div class="player-bet ${betStatusClass}">${betDisplay}</div>
                            <div class="player-cards-hand"></div>
                        </div>`;
                    
                    playerCardsContainer.appendChild(playerDiv);
                });

            } else {
                // Lógica para 1 o más de 2 jugadores
                playerCardsContainer.classList.remove('two-players');
                const reorderedPlayers = [...players];
                const currentPlayerOriginalIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

                if (currentPlayerOriginalIndex > -1) {
                    const [currentPlayer] = reorderedPlayers.splice(currentPlayerOriginalIndex, 1);
                    const middleIndex = Math.floor(reorderedPlayers.length / 2);
                    reorderedPlayers.splice(middleIndex, 0, currentPlayer);
                }

                const centerIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

                reorderedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    let positionClass = '';

                    if (index === centerIndex) {
                        positionClass = 'curve-center';
                    } else if (centerIndex !== -1 && index < centerIndex) {
                        positionClass = 'curve-left';
                    } else {
                        positionClass = 'curve-right';
                    }

                    playerDiv.className = `player-position ${positionClass}`;
                    playerDiv.dataset.playerId = player.id;

                    let betDisplay = '';
                    let betStatusClass = '';

                    if (player.betConfirmed && player.bet > 0) {
                        betDisplay = `<div class="bet-confirmed-icon">${player.bet}</div>`;
                        betStatusClass = 'bet-confirmed';
                    } else if (player.bet > 0) {
                        betDisplay = `<div class="bet-pending">${player.bet} (Pendiente)</div>`;
                        betStatusClass = 'bet-pending';
                    } else {
                        betDisplay = ``;
                        betStatusClass = 'no-bet';
                    }

                    playerDiv.innerHTML = `
                        <div class="player-content">
                            <div class="player-info-display">${player.name}</div>
                            <div class="player-bet ${betStatusClass}">${betDisplay}</div>
                            <div class="player-cards-hand"></div>
                        </div>`;
                    
                    playerCardsContainer.appendChild(playerDiv);
                });
            }

            // Agregar estilos si no existen
            addPlayerStyles();
        }

        function addPlayerStyles() {
            if (!document.getElementById('player-bet-styles')) {
                const style = document.createElement('style');
                style.id = 'player-bet-styles';
                style.innerHTML = `
                    .player-info-display {
                        color: white;
                        font-weight: bold;
                        margin-bottom: 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        height: 2.5em; /* Altura fija para evitar saltos de layout */
                        width: 150px; /* Ancho fijo para evitar que el texto cambie el tamaño */
                    }

                    .player-position {
                        position: relative;
                        overflow: visible;
                        margin: 10px;
                        padding: 10px;
                        border-radius: 10px;
                        border: 2px solid transparent;
                        transition: all 0.3s ease;
                    }
                    .player-content {
                        transition: transform 0.3s ease;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 10px;
                    }
                    .player-position.current-turn .player-content {
                        transform: scale(1.05);
                    }
                    .player-info-display.status-bust {
                        color: #e74c3c;
                    }
                    .player-info-display.status-stand {
                        color: #3498db;
                    }

                    /* --- JERARQUÍA DE ESTILOS DE BORDE --- */
                    
                    /* 1. Turno Actual (Prioridad Baja) */
                    .player-position.current-turn .card {
                        border: 3px solid #4eb8ff !important;
                        box-shadow: 0 0 12px rgba(78, 184, 255, 0.8) !important;
                    }

                    /* 2. Plantado (Prioridad Media) - Sobrescribe al turno actual */
                    .player-position .card.stood-card {
                        border: 3px solid #3498db !important;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.7) !important;
                    }

                    /* 3. Pasado (Prioridad Máxima) - Sobrescribe a todos los demás */
                    .player-position .card.busted-card {
                        border: 3px solid #e74c3c !important;
                        box-shadow: 0 0 12px rgba(231, 76, 60, 0.8) !important;
                    }

                    /* 4. Resultado de la Ronda (Prioridad Máxima) */
                    .player-position .card.card-win-border,
                    .dealer-hand .card.card-win-border {
                        border: 4px solid #2ecc71 !important;
                        box-shadow: 0 0 15px rgba(46, 204, 113, 0.9) !important;
                    }

                    .player-position .card.card-lose-border,
                    .dealer-hand .card.card-lose-border {
                        border: 4px solid #e74c3c !important;
                        box-shadow: 0 0 15px rgba(231, 76, 60, 0.9) !important;
                    }

                    /* Estilos para la lista de resultados en el modal */
                    .results-list { width: 100%; margin-bottom: 20px; }
                    .results-header, .results-row {
                        display: flex;
                        justify-content: space-between;
                        padding: 10px 15px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    }
                    .results-header {
                        font-weight: bold;
                        color: #D4AF37;
                        background: rgba(255, 255, 255, 0.05);
                        border-top-left-radius: 8px;
                        border-top-right-radius: 8px;
                    }
                    .results-row span:last-child {
                        font-weight: bold;
                    }
                    .waiting-next-round {
                        margin-top: 15px;
                        color: #ccc;
                        box-shadow: 0 0 15px #D4AF37;
                    }

                    .bet-confirmed-icon {
                        color: #27ae60;
                        font-size: 1.2em;
                        margin-top: 5px;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    }
                    
                    .bet-pending {
                        color: #f39c12;
                        font-weight: bold;
                        margin-top: 5px;
                    }
                    
                    .no-bet {
                        color: rgba(255, 255, 255, 0.5);
                        margin-top: 5px;
                    }
                    
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                        100% { transform: scale(1); }
                    }
                    
                    .betting-controls-disabled .chip,
                    .betting-controls-disabled button {
                        pointer-events: none !important;
                        opacity: 0.4 !important;
                    }
                    
                    .dealing-animation {
                        position: fixed;
                        z-index: 2000;
                        transition: all 0.6s cubic-bezier(0.25, 1, 0.5, 1);
                        transform-origin: center center;
                    }

                    .notification {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #27ae60;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 1000;
                        animation: slideIn 0.5s ease;
                    }
                    
                    @keyframes slideIn {
                        from { transform: translateX(100%); }
                        to { transform: translateX(0); }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function addResultStyles() {
            if (document.getElementById('game-result-styles')) return;
            const style = document.createElement('style');
            style.id = 'game-result-styles';
            style.innerHTML = `
                .result-overlay {
                    position: absolute;
                    top: 0;
                    left: -30px; /* Ensanchar para cubrir el abanico */
                    right: -30px; /* Ensanchar para cubrir el abanico */
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    border-radius: 10px;
                    z-index: 15;
                    text-align: center;
                    animation: fadeIn 0.5s;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                .result-overlay .outcome-text {
                    font-size: 2.5em;
                    font-weight: bold;
                    text-transform: uppercase;
                    text-shadow: 2px 2px 5px #000;
                }
                .result-overlay .score-text {
                    font-size: 1.2em;
                    margin-top: 5px;
                }
            `;
            document.head.appendChild(style);
        }

        function highlightCurrentPlayerUI(playerId, playerName) {
            
            // 1. Limpiar todos los highlights y mensajes de turno previos
            document.querySelectorAll('.player-position').forEach(div => {
                div.classList.remove('current-turn');
                const infoDisplay = div.querySelector('.player-info-display');
                
                // Si el texto no es un estado final (plantado/perdido), lo reseteamos al nombre.
                if (infoDisplay && !infoDisplay.classList.contains('status-stand') && !infoDisplay.classList.contains('status-bust')) {
                    const originalPlayerId = div.dataset.playerId;
                    const originalPlayer = playersList.find(p => p.id === originalPlayerId);
                    if (originalPlayer) {
                        infoDisplay.innerHTML = originalPlayer.name;
                    }
                }
            });

            // 2. Determinar si es mi turno y actualizar la UI
            const isMyTurn = window.socket.id === playerId;
            const playerActions = document.getElementById('playerActions');

            if (isMyTurn) {
                // Es mi turno: muestro mis botones de acción y resalto mi área.
                playerActions.style.display = 'flex';
                const myPlayerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
                if (myPlayerDiv) {
                    myPlayerDiv.classList.add('current-turn');
                    const infoDisplay = myPlayerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `Es <strong>tu</strong> turno`;
                    }
                }
            } else {
                // No es mi turno: oculto mis botones.
                playerActions.style.display = 'none';
                
                if (playerId) { // Es el turno de otro jugador
                    const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
                    if (playerDiv) {
                        playerDiv.classList.add('current-turn');
                        const infoDisplay = playerDiv.querySelector('.player-info-display');
                        // Solo actualizamos si no tiene ya un estado final
                        if (infoDisplay && !infoDisplay.classList.contains('status-stand') && !infoDisplay.classList.contains('status-bust')) {
                            infoDisplay.innerHTML = `Turno de <strong>${playerName}</strong>`;
                        }
                    }
                }
                // Si playerId es null (turno del dealer), no se muestra ningún mensaje en las áreas de los jugadores.
            }
        }

        // === LÓGICA DE ANIMACIÓN DE CARTAS (IDÉNTICA A LA DEL DEALER) ===

        function createCardElement(card) {
            const cardDiv = document.createElement('div');
            
            if (card.hidden) {
                cardDiv.className = 'card card-back';
                return cardDiv;
            }

            // Usar la imagen de la carta como fondo
            cardDiv.className = 'card';
            cardDiv.style.backgroundImage = `url('/${card.src}')`;
            cardDiv.style.backgroundSize = 'cover';
            cardDiv.style.backgroundPosition = 'center';
            cardDiv.style.backgroundRepeat = 'no-repeat';

            return cardDiv;
        }

        async function animateDealing(players, dealerHand) {
            const deckElement = document.querySelector('.deck-pile');
            if (!deckElement) return;

            const deckRect = deckElement.getBoundingClientRect();
            const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

            const dealSequence = [];

            // Ronda 1
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[0] });

            // Ronda 2
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[1] });

            // Ronda 3
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[2] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[2] });

            for (const deal of dealSequence) {
                await dealOneCard(deal, deckRect);
            }
            // Aplicar el efecto abanico una vez que todas las cartas se han repartido
            applyFanEffect();
        }

        function dealOneCard(deal, deckRect) {
            return new Promise(resolve => {
                let targetHandElement;
                if (deal.target === 'player') {
                    targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
                } else {
                    targetHandElement = document.getElementById('dealerCards');
                }

                if (!targetHandElement) {
                    // Si no se encuentra el contenedor, simplemente resolvemos la promesa para no detener la secuencia.
                    console.warn(`No se encontró el contenedor de mano para ${deal.target} ${deal.id || ''}`);
                    return resolve();
                }

                const cardElement = createCardElement(deal.card);
                cardElement.classList.add('dealing-animation');
                cardElement.style.left = `${deckRect.left}px`;
                cardElement.style.top = `${deckRect.top}px`;
                document.body.appendChild(cardElement);

                const targetRect = targetHandElement.getBoundingClientRect();
                // Apuntar la animación al centro del contenedor de la mano para un aterrizaje suave.
                // Restamos la mitad del ancho/alto de la carta para centrarla.
                const cardWidth = 80;
                const cardHeight = 120;
                const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
                const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

                setTimeout(() => {
                    // Detectar si el jugador está en una posición lateral
                    let isSidePlayer = false;
                    if (deal.target === 'player') {
                        const playerDiv = document.querySelector(`.player-position[data-player-id="${deal.id}"]`);
                        if (playerDiv && (playerDiv.classList.contains('curve-left') || playerDiv.classList.contains('curve-right'))) {
                            isSidePlayer = true;
                        }
                    }

                    let finalTransform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;
                    // Si es un jugador lateral, la animación termina con la carta encogiéndose
                    if (isSidePlayer) {
                        finalTransform += ' scale(0.1)';
                    }
                    cardElement.style.transform = finalTransform;

                    cardElement.addEventListener('transitionend', () => {
                        cardElement.remove(); // Eliminar la carta animada
                        // Solo añadir la carta estática si no es un jugador lateral
                        if (!isSidePlayer) {
                            const finalCard = createCardElement(deal.card);
                            finalCard.style.position = 'absolute';
                            targetHandElement.appendChild(finalCard);
                            applyFanEffect(); // Re-aplicar el abanico para un efecto progresivo
                        }
                        resolve();
                    }, { once: true });
                }, 50);
            });
        }

        function applyFanEffect() {
            const hands = document.querySelectorAll('.player-cards-hand, #dealerCards');

            hands.forEach(hand => {
                hand.style.position = 'relative';

                const cards = hand.querySelectorAll('.card');
                const total = cards.length;
                if (total === 0) return;

                const maxAngle = 20; // Ángulo máximo de rotación
                const horizontalSpread = window.innerWidth < 568 ? 20 : 30; // Separación de cartas responsive
                const totalWidth = (total - 1) * horizontalSpread;

                cards.forEach((card, index) => {
                    const pivotIndex = (total - 1) / 2;
                    let angle = 0;
                    if (total > 1 && pivotIndex > 0) {
                        angle = (index - pivotIndex) * (maxAngle / pivotIndex);
                    }
                    const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);
                    
                    card.style.left = '50%';
                    card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
                });
            });
        }

        // === FUNCIONES DE APUESTA ===

        function updateBetDisplay() {
            balanceEl.textContent = `$${currentBalance}`;
            totalBetEl.textContent = `$${currentBet}`;
        }

        function updateBettingControls() {
            if (betConfirmed || gameState !== 'betting') {
                bettingArea.classList.add('betting-controls-disabled');
            } else {
                bettingArea.classList.remove('betting-controls-disabled');
            }
        }

        function placeBet(amount) {
            if (betConfirmed || gameState !== 'betting') {
                alert('No se pueden hacer apuestas en este momento');
                return;
            }
            
            const newBet = currentBet + amount;
            if (newBet > currentBalance) {
                alert("No tienes suficiente saldo para esa apuesta.");
                return;
            }
            
            currentBet = newBet;
            updateBetDisplay();
            window.socket.emit('playerBet', { bet: currentBet });
        }

        function clearBet() {
            if (betConfirmed) return;
            // Usar el evento específico del servidor para cancelar la apuesta.
            window.socket.emit('cancelBet');
        }

        function confirmBet() {
            if (currentBet === 0) {
                alert("Debes realizar una apuesta antes de confirmar.");
                return;
            }
            
            if (betConfirmed) {
                alert("Ya confirmaste tu apuesta.");
                return;
            }

            // Confirmar en el servidor
            window.socket.emit('playerConfirmBet');
            console.log(`Confirmando apuesta de $${currentBet}`);

            // Ocultar el modal inmediatamente para este jugador
            bettingArea.style.display = 'none';
        }

        // === FUNCIONES DE UTILIDAD ===

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function copyRoomCode() {
            if (roomCode) {
                navigator.clipboard.writeText(roomCode)
                    .then(() => {
                        showNotification('¡Código copiado al portapapeles!', 'success');
                    })
                    .catch(err => {
                        console.error('Error al copiar:', err);
                        const textArea = document.createElement('textarea');
                        textArea.value = roomCode;
                        document.body.appendChild(textArea);
                        textArea.select();
                        try {
                            document.execCommand('copy');
                            showNotification('¡Código copiado al portapapeles!', 'success');
                        } catch (fallbackErr) {
                            showNotification('Error al copiar código', 'error');
                        }
                        document.body.removeChild(textArea);
                    });
            }
        }

        async function exitRoom() {
            if (confirm('¿Seguro que quieres salir de la mesa?')) {
                try {
                    showNotification('Saliendo de la mesa...', 'info');
                    
                    // Notificar al servidor que el jugador está saliendo.
                    // El servidor se encargará de actualizar el conteo y el estado de la mesa.
                    await fetch('/salir-mesa', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ codigo: roomCode })
                    });

                } catch (error) {
                    console.error('Error al notificar al servidor sobre la salida:', error);
                } finally {
                    // Redirigir a la página de inicio, independientemente de si la llamada a la API tuvo éxito.
                    // La desconexión del socket también limpiará al jugador en el servidor como respaldo.
                    window.location.href = '/';
                }
            }
        }

        // Inicializar
        updateBetDisplay();
    </script>

</body>

</html>
