<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="/css/players.css">
</head>

<body>
    <!-- HEADER -->
    <header class="top-bar">
        <div class="left-group">
            <button class="exit-btn" onclick="exitRoom()">
                <i class="fas fa-door-open"></i> EXIT ROOM
            </button>
            <!-- El contador de jugadores ahora est√° en el header -->
            <div class="online-status">
                <div class="status-icon"></div>
                <span class="user-icon">üë•</span>
                <h2 id="contador">0</h2>
            </div>
        </div>

        <div class="dealer-title">PLAYER VIEW</div>

        <!-- Bot√≥n Hamburguesa -->
        <button class="menu-toggle" id="menuToggle">
            <i class="fas fa-bars"></i>
        </button>

        <!-- Men√∫ Oculto (en m√≥viles) -->
        <nav class="mobile-menu" id="mobileMenu">
            <button class="how-to-play">üîä HOW TO PLAY</button>
            <button class="exit-btn" onclick="exitRoom()">EXIT</button>
            <button>COPY INVITE</button>
        </nav>

        <!-- Bot√≥n normal en escritorio -->
        <button class="how-to-play desktop-only">üîä HOW TO PLAY</button>
    </header>

    <!-- √ÅREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- √ÅREA DEL DEALER (ARRIBA) -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>
            <div class="dealer-hand" id="dealerCards">
                <!-- Las cartas del dealer se renderizar√°n aqu√≠ -->
            </div>
        </div>

        <!-- SVG DECORATIVO (CENTRO) -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <!-- Curvas alineadas -->
                    <path id="curve-top" d="M 150 150 Q 500 220 850 150" />
                    <path id="curve-bottom" d="M 150 200 Q 500 270 850 200" />
                    <path id="curve-middle" d="M 130 208 Q 500 278 870 208" />

                    <!-- Efectos de sombra -->
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>

                <!-- L√≠nea decorativa visible que sigue la curva del texto -->
                <use href="#curve-middle" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />

                <!-- Texto superior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK 31 PAYS 3 TO 2
                    </textPath>
                </text>

                <!-- Texto inferior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 27 AND DRAW TO 26
                    </textPath>
                </text>
            </svg>
        </div>
        <!-- √ÅREA DEL JUGADOR (ABAJO) -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <!-- Los jugadores se renderizar√°n aqu√≠ din√°micamente -->
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>
    </div>

    <!-- √ÅREA DE APUESTAS -->
    <div class="betting-area" id="bettingArea" style="display: none;">
        <div class="betting-modal-content">
            <div class="balance-info">
                <div>Balance</div>
                <div id="balance">$100</div>
            </div>
            <div>Total Bet<br><span id="totalBet">$0</span></div>
            <div class="chips">
                <div class="chip chip-10" onclick="placeBet(10)">$10</div>
                <div class="chip chip-25" onclick="placeBet(25)">$25</div>
                <div class="chip chip-50" onclick="placeBet(50)">$50</div>
                <div class="chip chip-100" onclick="placeBet(100)">$100</div>
            </div>
            <div class="betting-buttons">
                <button onclick="clearBet()">CLEAR</button>
                <button onclick="maxBet()">MAX</button> 
                <button id="confirmBetBtn" onclick="confirmBet()">CONFIRM BET</button>
            </div>
        </div>
    </div>

    <!-- √ÅREA DE ACCIONES DEL JUGADOR -->
    <div class="player-actions" id="playerActions" style="display: none;">
        <button id="hitBtn" class="action-btn hit">Pedir</button>
        <button id="standBtn" class="action-btn stand">Plantarse</button>
        <button id="doubleBtn" class="action-btn double">Doblar</button>
        <button id="splitBtn" class="action-btn split" disabled>Dividir</button>
    </div>

    <!-- BOT√ìN SALIR -->
    <button class="leave-table" onclick="exitRoom()">üö™ LEAVE TABLE</button>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/sidebar.js"></script>
    <script>
        // Variables globales
        window.socket = io();
        let currentBalance = 100; // Valor inicial, se sincronizar√° con el servidor
        let currentBet = 0;
        let betConfirmed = false;
        let gameState = 'waiting';
        let currentPlayerName = '';
        let playersList = []; // Lista de jugadores para referencia
        let roomCode = '';

        const balanceEl = document.getElementById('balance');
        const totalBetEl = document.getElementById('totalBet');
        const bettingArea = document.getElementById('bettingArea');

        document.addEventListener('DOMContentLoaded', () => {
            const params = new URLSearchParams(window.location.search);
            roomCode = params.get('codigo');
            currentPlayerName = params.get('nombre');

            // Unirse a la sala
            if (roomCode && window.socket) {
                window.socket.emit('joinRoom', roomCode, currentPlayerName);
            }

            // === MANEJO DEL MEN√ö HAMBURGUESA ===
            const menuToggle = document.getElementById('menuToggle');
            const mobileMenu = document.getElementById('mobileMenu');

            if (menuToggle && mobileMenu) {
                menuToggle.addEventListener('click', (e) => {
                    e.stopPropagation(); // Evita que el evento de clic se propague al 'window'
                    mobileMenu.classList.toggle('active');
                });

                // Listener para cerrar el men√∫ si se hace clic fuera de √©l
                window.addEventListener('click', (e) => {
                    if (mobileMenu.classList.contains('active') && !mobileMenu.contains(e.target) && !menuToggle.contains(e.target)) {
                        mobileMenu.classList.remove('active');
                    }
                });
            }

            // === EVENT LISTENERS PARA ACCIONES ===
            document.getElementById('hitBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerHit');
                window.socket.emit('playerHit');
            });

            document.getElementById('standBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerStand');
                window.socket.emit('playerStand');
            });

            // === EVENTOS DEL SERVIDOR ===

            // Lista de jugadores actualizada
            window.socket.on('updatePlayerList', (players) => {
                console.log('Lista de jugadores actualizada:', players);
                playersList = players; // Guardar la lista globalmente
                renderPlayers(players, currentPlayerName);
                document.getElementById('contador').textContent = players.length;

                // Actualizar nuestro balance si existe en la lista
                const currentPlayer = players.find(p => p.name === currentPlayerName);
                if (currentPlayer) {
                    // El balance puede ser 0, lo cual es un valor v√°lido. No usar '||' para fallback.
                    currentBalance = (currentPlayer.balance !== null && currentPlayer.balance !== undefined) ? currentPlayer.balance : 100;
                    currentBet = currentPlayer.bet || 0;
                    betConfirmed = currentPlayer.betConfirmed || false;
                    updateBetDisplay();
                    updateBettingControls();
                }
            });

            // Estado del juego actualizado
            window.socket.on('gameStateUpdate', (data) => {
                gameState = data.state;
                console.log('Estado del juego:', gameState);
                
                // Mostrar/ocultar √°rea de apuestas seg√∫n el estado
                    if (gameState === 'betting') {
                    bettingArea.style.display = 'flex';
                } else {
                    bettingArea.style.display = 'none';
                }

                updateBettingControls();
            });

            // Per√≠odo de apuestas iniciado
            window.socket.on('bettingStarted', (data) => {
                console.log('Per√≠odo de apuestas iniciado:', data.duration + 'ms');
                bettingArea.style.display = 'flex';
                
                // Opcional: mostrar countdown
                showBettingTimer(data.duration);
            });

            // Apuestas cerradas
            window.socket.on('bettingClosed', () => {
                console.log('Per√≠odo de apuestas cerrado');
                disableAllBettingControls();
            });

            // Jugador confirm√≥ apuesta
            window.socket.on('playerBetConfirmed', (data) => {
                console.log(`${data.playerName} confirm√≥ apuesta de $${data.bet}`);
                showNotification(`${data.playerName} confirm√≥ apuesta de $${data.bet}`);
            });

            // Iniciar juego
            window.socket.on('startGame', () => {
                console.log('¬°Juego iniciado! Todos los jugadores confirmaron sus apuestas');
                showNotification('¬°Juego iniciado! Repartiendo cartas...');
                bettingArea.style.display = 'none';
            });

            // Errores de apuesta
            window.socket.on('betError', (data) => {
                alert('Error en apuesta: ' + data.errors.join(', '));
            });

            // Apuesta actualizada
            window.socket.on('betUpdated', (data) => {
                console.log('Apuesta actualizada a:', data.bet);
            });

            // Apuesta cancelada
            window.socket.on('betCancelled', () => {
                console.log('Apuesta cancelada');
                currentBet = 0;
                updateBetDisplay();
            });

            window.socket.on('turnUpdate', (data) => {
                console.log(`[TURN] Turno de: ${data.playerName}`);
                highlightCurrentPlayerUI(data.playerId, data.playerName);
            });

            window.socket.on('gameReset', () => {
                console.log('üîÑ Juego reiniciado.');
                showNotification('El juego ha sido reiniciado.');
                // Limpiar la mano del dealer
                document.getElementById('dealerCards').innerHTML = '';
                // Limpiar el mensaje de turno. El resto de la UI se limpia con 'updatePlayerList'
                document.getElementById('playerActions').style.display = 'none';
                const turnDisplay = document.getElementById('turnDisplay');
                // Limpiar overlays de resultados
                document.querySelectorAll('.result-overlay').forEach(o => o.remove());
                document.querySelectorAll('.busted').forEach(b => b.classList.remove('busted'));
                const dealerScore = document.querySelector('.dealer-score-display');
                if (dealerScore) dealerScore.remove();
                if (turnDisplay) turnDisplay.remove();
            });

            // Errores generales
            window.socket.on('error', (data) => {
                alert('Error: ' + data.message);
            });

            window.socket.on('cardsDealt', (data) => {
                console.log('üÉè Recibiendo cartas del servidor:', data);
                
                // Limpiar manos actuales antes de repartir
                document.getElementById('dealerCards').innerHTML = '';
                document.querySelectorAll('.player-cards-hand').forEach(hand => {
                    hand.innerHTML = '';
                });

                // Ocultar √°rea de apuestas y deshabilitar controles
                bettingArea.style.display = 'none';
                // Ocultar botones de acci√≥n al repartir, se mostrar√°n cuando sea el turno
                document.getElementById('playerActions').style.display = 'none';
                animateDealing(data.players, data.dealer);
            });
            
            // Un jugador (o yo) recibe una nueva carta
            window.socket.on('playerCardUpdate', (data) => {
                console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);
                
                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'player',
                    id: data.playerId,
                    card: data.newCard,
                };
                // Animar solo la nueva carta que se reparte
                dealOneCard(dealInfo, deckRect);
            });

            // Un jugador se pasa de 21
            window.socket.on('playerBust', (data) => {
                console.log(`[BUST] ${data.playerName} se ha pasado.`);
                showNotification(`${data.playerName} se pas√≥ con ${data.score}!`, 'error');
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    playerDiv.classList.add('busted');
                }
                // Si soy yo quien se ha pasado, oculto mis botones de acci√≥n.
                if (data.playerId === window.socket.id) {
                    document.getElementById('playerActions').style.display = 'none';
                }
            });

            // El turno pasa al dealer
            window.socket.on('dealerTurn', () => {
                console.log('[DEALER TURN] Turno del dealer.');
                showNotification('Turno del Dealer. Revelando carta...', 'info');
                // Des-resaltar a todos y mostrar mensaje del dealer
                // El null en playerId se encarga de que no se resalte a nadie
                // y el mensaje se actualice correctamente.
                highlightCurrentPlayerUI(null, 'Dealer');
            });

            // El dealer revela su carta
            window.socket.on('revealDealerCard', (data) => {
                console.log('[DEALER REVEAL] El dealer revela su mano completa:', data.dealerHand);
                const dealerHandContainer = document.getElementById('dealerCards');
                
                // Limpiar la mano actual del dealer (que contiene cartas ocultas)
                dealerHandContainer.innerHTML = '';

                // Renderizar la mano completa del dealer con todas las cartas visibles
                data.dealerHand.forEach(cardData => {
                    const cardElement = createCardElement(cardData);
                    cardElement.style.position = 'absolute'; // Necesario para el efecto abanico
                    dealerHandContainer.appendChild(cardElement);
                });
                
                applyFanEffect(); // Re-aplicar el efecto abanico para ajustar las posiciones
            });

            // El dealer pide una carta (Hit)
            window.socket.on('dealerCardUpdate', (data) => {
                console.log(`[DEALER HIT] Dealer recibe una carta.`);
                
                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'dealer',
                    card: data.newCard,
                };
                // Animar la carta que pide el dealer
                dealOneCard(dealInfo, deckRect);
            });

            // Resultados del juego
            window.socket.on('gameResults', (data) => {
                console.log('[RESULTS] Resultados recibidos:', data);
                showNotification('Ronda finalizada. Mostrando resultados...', 'success');
                addResultStyles(); // Asegurarse de que los estilos existan

                // Ocultar el mensaje de turno y los botones de acci√≥n
                const turnDisplay = document.getElementById('turnDisplay');
                if (turnDisplay) turnDisplay.style.display = 'none';
                document.getElementById('playerActions').style.display = 'none';

                data.results.forEach(result => {
                    const playerDiv = document.querySelector(`.player-position[data-player-id="${result.playerId}"]`);
                    if (playerDiv) {
                        // Crear un div para el resultado
                        const resultOverlay = document.createElement('div');
                        resultOverlay.className = `result-overlay result-${result.outcome.toLowerCase()}`;
                        
                        resultOverlay.innerHTML = `
                            <div class="outcome-text">${result.outcome}</div>
                            <div class="score-text">Puntos: ${result.playerScore}</div>
                        `;
                        
                        playerDiv.appendChild(resultOverlay);

                        // Actualizar nuestro propio balance
                        if (result.playerId === window.socket.id) {
                            currentBalance = result.newBalance;
                            updateBetDisplay();
                        }
                    }
                });

                // Mostrar la puntuaci√≥n final del dealer
                const dealerHandContainer = document.getElementById('dealerCards');
                // Remover score display anterior si existe
                const oldScoreDisplay = dealerHandContainer.querySelector('.dealer-score-display');
                if (oldScoreDisplay) oldScoreDisplay.remove();

                const dealerScoreDisplay = document.createElement('div');
                dealerScoreDisplay.className = 'dealer-score-display';
                let dealerText = `Puntuaci√≥n del Dealer: ${data.dealerScore}`;
                if (data.dealerScore > 31) {
                    dealerText += ' (BUST)';
                } else if (data.dealerScore === 31 && document.getElementById('dealerCards').querySelectorAll('.card').length === 2) {
                    dealerText += ' (BLACKJACK)';
                }
                dealerScoreDisplay.textContent = dealerText;
                dealerHandContainer.appendChild(dealerScoreDisplay);
            });
        });

        // === FUNCIONES DE RENDERIZADO ===

        function renderPlayers(players, currentPlayerName) {
            const playerCardsContainer = document.getElementById('playerCards');
            playerCardsContainer.innerHTML = '';

            if (players.length === 0) {
                playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
                return;
            }

            // Reordenar jugadores para que el actual est√© en el centro
            const reorderedPlayers = [...players];
            const currentPlayerOriginalIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

            if (currentPlayerOriginalIndex > -1) {
                const [currentPlayer] = reorderedPlayers.splice(currentPlayerOriginalIndex, 1);
                const middleIndex = Math.floor(reorderedPlayers.length / 2);
                reorderedPlayers.splice(middleIndex, 0, currentPlayer);
            }

            const centerIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

            reorderedPlayers.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                let positionClass = '';

                if (index === centerIndex) {
                    positionClass = 'curve-center';
                } else if (centerIndex !== -1 && index < centerIndex) {
                    positionClass = 'curve-left';
                } else {
                    positionClass = 'curve-right';
                }

                playerDiv.className = `player-position ${positionClass}`;
                playerDiv.dataset.playerId = player.id; // <-- IMPORTANTE para la animaci√≥n

                let betDisplay = '';
                let floatingBetHtml = '';
                let betStatusClass = '';

                if (player.betConfirmed && player.bet > 0) {
                    // Apuesta confirmada
                    floatingBetHtml = ``; // Ya no se necesita el globo flotante
                    // Mostrar el monto de la apuesta en lugar del √≠cono
                    betDisplay = `<div class="bet-confirmed-icon">$${player.bet}</div>`;
                    betStatusClass = 'bet-confirmed';
                } else if (player.bet > 0) {
                    // Apuesta pendiente
                    betDisplay = `<div class="bet-pending">$${player.bet} (Pendiente)</div>`;
                    betStatusClass = 'bet-pending';
                } else {
                    // Sin apuesta
                    betDisplay = ``;
                    betStatusClass = 'no-bet';
                }

                playerDiv.innerHTML = `
                    <div class="player-header">
                        <div class="player-name-display ${player.name === currentPlayerName ? 'current-player' : ''}">${player.name}</div>
                        ${floatingBetHtml}
                    </div>
                    <div class="player-cards-hand">
                        <div class="card-slot">
                            Esperando cartas...
                        </div>
                    </div>
                    <div class="player-bet ${betStatusClass}">${betDisplay}</div>`;
                
                playerCardsContainer.appendChild(playerDiv);
            });

            // Agregar estilos si no existen
            addPlayerStyles();
        }

        function addPlayerStyles() {
            if (!document.getElementById('player-bet-styles')) {
                const style = document.createElement('style');
                style.id = 'player-bet-styles';
                style.innerHTML = `
                    .player-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        color: white;
                        font-weight: bold;
                        margin-bottom: 5px;
                    }
                    
                    .current-player {
                        color: #FFD700 !important;
                        text-shadow: 0 0 10px #FFD700;
                    }
                    
                    .player-position {
                        position: relative;
                        overflow: visible;
                        margin: 10px;
                        padding: 10px;
                        border-radius: 10px;
                        border: 2px solid transparent;
                        transition: all 0.3s ease;
                    }
                    
                    .confirmed-bet-floater {
                        position: absolute;
                        top: -10px;
                        right: -10px;
                        background-color: #27ae60;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 15px;
                        border: 2px solid white;
                        box-shadow: 0 0 10px rgba(39, 174, 96, 0.7);
                        z-index: 10;
                        animation: pulse 2s infinite;
                    }
                    
                    .player-position.current-turn {
                        border-color: #3498db;
                        box-shadow: 0 0 20px rgba(52, 152, 219, 0.7);
                        transform: scale(1.05);
                    }

                    .turn-display-message {
                        text-align: center;
                        padding: 10px 20px;
                        margin-bottom: -20px;
                        background: rgba(0, 0, 0, 0.4);
                        border-radius: 8px;
                        font-size: 1.2em;
                        color: #fff;
                        border: 1px solid rgba(255, 255, 255, 0.2);
                        transition: all 0.3s;
                        position: relative;
                        z-index: 5;
                    }

                    .turn-display-message.my-turn {
                        background: #D4AF37;
                        color: #000;
                        font-weight: bold;
                        border-color: #fff;
                        box-shadow: 0 0 15px #D4AF37;
                    }

                    .player-position.busted {
                        background: rgba(192, 57, 43, 0.4);
                        border-color: #e74c3c;
                        opacity: 0.8;
                        filter: grayscale(50%);
                    }

                    .player-position.busted::after {
                        content: 'BUST';
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%) rotate(-15deg);
                        font-size: 3em;
                        font-weight: bold;
                        color: rgba(255, 255, 255, 0.7);
                        text-shadow: 2px 2px 5px #000;
                        z-index: 20;
                        pointer-events: none;
                    }

                    .card-slot {
                        border: 2px dashed rgba(255, 255, 255, 0.3);
                        border-radius: 10px;
                        padding: 20px 10px;
                        text-align: center;
                        color: rgba(255, 255, 255, 0.5);
                        margin: 10px 0;
                    }
                    
                    .bet-confirmed-icon {
                        color: #27ae60;
                        font-size: 1.2em;
                        margin-top: 5px;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    }
                    
                    .bet-pending {
                        color: #f39c12;
                        font-weight: bold;
                        margin-top: 5px;
                    }
                    
                    .no-bet {
                        color: rgba(255, 255, 255, 0.5);
                        margin-top: 5px;
                    }
                    
                    .player-balance {
                        font-size: 0.9em;
                        color: #D4AF37;
                        margin-top: 5px;
                    }
                    
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                        100% { transform: scale(1); }
                    }
                    
                    .betting-controls-disabled .chip,
                    .betting-controls-disabled button {
                        pointer-events: none !important;
                        opacity: 0.4 !important;
                    }
                    
                    .dealing-animation {
                        position: fixed;
                        z-index: 2000;
                        transition: all 0.6s cubic-bezier(0.25, 1, 0.5, 1);
                        transform-origin: center center;
                    }

                    .notification {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #27ae60;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 1000;
                        animation: slideIn 0.5s ease;
                    }
                    
                    @keyframes slideIn {
                        from { transform: translateX(100%); }
                        to { transform: translateX(0); }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function addResultStyles() {
            if (document.getElementById('game-result-styles')) return;
            const style = document.createElement('style');
            style.id = 'game-result-styles';
            style.innerHTML = `
                .result-overlay {
                    position: absolute;
                    top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    border-radius: 10px;
                    z-index: 15;
                    text-align: center;
                    animation: fadeIn 0.5s;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                .result-overlay .outcome-text {
                    font-size: 2.5em;
                    font-weight: bold;
                    text-transform: uppercase;
                    text-shadow: 2px 2px 5px #000;
                }
                .result-overlay .score-text {
                    font-size: 1.2em;
                    margin-top: 5px;
                }
                .result-overlay.result-win, .result-overlay.result-blackjack { background: rgba(39, 174, 96, 0.7); }
                .result-overlay.result-lose { background: rgba(192, 57, 43, 0.7); }
                .result-overlay.result-push { background: rgba(44, 62, 80, 0.7); }
                .dealer-score-display {
                    position: absolute;
                    bottom: -30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0,0,0,0.7);
                    color: #FFD700;
                    padding: 5px 15px;
                    border-radius: 10px;
                    font-weight: bold;
                    white-space: nowrap;
                }`;
            document.head.appendChild(style);
        }

        function highlightCurrentPlayerUI(playerId, playerName) {
            // Remover highlights previos
            document.querySelectorAll('.player-position').forEach(div => {
                div.classList.remove('current-turn');
            });

            // Resaltar al jugador actual
            if (playerId) {
                const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
                if (playerDiv) {
                    playerDiv.classList.add('current-turn');
                }
            }

            // Mostrar mensaje de turno
            let turnDisplay = document.getElementById('turnDisplay');
            if (!turnDisplay) {
                turnDisplay = document.createElement('div');
                turnDisplay.id = 'turnDisplay';
                turnDisplay.className = 'turn-display-message';
                
                const playerArea = document.querySelector('.player-area');
                // Insertar antes del √°rea de jugadores para que est√© arriba
                playerArea.parentNode.insertBefore(turnDisplay, playerArea);
            }
            
            const isMyTurn = window.socket.id === playerId;
            const playerActions = document.getElementById('playerActions');

            if (isMyTurn) {
                turnDisplay.innerHTML = `<span>Es <strong>tu turno</strong> para jugar.</span>`;
                turnDisplay.classList.add('my-turn');
                playerActions.style.display = 'flex';
            } else {
                playerActions.style.display = 'none';
                if (playerId) { // Otro jugador
                    turnDisplay.innerHTML = `<span>Turno de <strong>${playerName}</strong>. Espera tu momento.</span>`;
                } else { // Turno del dealer o estado intermedio
                    turnDisplay.innerHTML = `<span>Turno del <strong>${playerName || 'Dealer'}</strong>.</span>`;
                }
                turnDisplay.classList.remove('my-turn');
            }
        }

        // === L√ìGICA DE ANIMACI√ìN DE CARTAS (ID√âNTICA A LA DEL DEALER) ===

        function createCardElement(card) {
            const cardDiv = document.createElement('div');
            
            if (card.hidden) {
                cardDiv.className = 'card card-back';
                return cardDiv;
            }

            // Usar la imagen de la carta como fondo
            cardDiv.className = 'card';
            cardDiv.style.backgroundImage = `url('/${card.src}')`;
            // Opcional: puedes dejar el texto superpuesto si tu CSS lo permite

    // Estilos para asegurar que la imagen se vea bien
    cardDiv.style.backgroundSize = 'cover'; // Escala la imagen para cubrir el div
    cardDiv.style.backgroundPosition = 'center'; // Centra la imagen
    cardDiv.style.backgroundRepeat = 'no-repeat'; // Evita que la imagen se repita

            return cardDiv;
        }

        async function animateDealing(players, dealerHand) {
            const deckElement = document.querySelector('.deck-pile');
            if (!deckElement) return;

            const deckRect = deckElement.getBoundingClientRect();
            const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

            const dealSequence = [];

            // Ronda 1
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[0] });

            // Ronda 2
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[1] });

            // Ronda 3
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[2] }));
            dealSequence.push({ target: 'dealer', card: dealerHand[2] });

            for (const deal of dealSequence) {
                await dealOneCard(deal, deckRect);
            }
            // Aplicar el efecto abanico una vez que todas las cartas se han repartido
            applyFanEffect();
        }

        function dealOneCard(deal, deckRect) {
            return new Promise(resolve => {
                let targetHandElement;
                if (deal.target === 'player') {
                    targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
                } else {
                    targetHandElement = document.getElementById('dealerCards');
                }

                if (!targetHandElement) return resolve();

                const cardElement = createCardElement(deal.card);
                cardElement.classList.add('dealing-animation');
                cardElement.style.left = `${deckRect.left}px`;
                cardElement.style.top = `${deckRect.top}px`;
                document.body.appendChild(cardElement);

                const targetRect = targetHandElement.getBoundingClientRect();
                // Apuntar la animaci√≥n al centro del contenedor de la mano para un aterrizaje suave.
                // Restamos la mitad del ancho/alto de la carta para centrarla.
                const cardWidth = 80;
                const cardHeight = 120;
                const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
                const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

                setTimeout(() => {
                    cardElement.style.transform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;
                    cardElement.addEventListener('transitionend', () => {
                        cardElement.remove(); // Eliminar la carta animada
                        const finalCard = createCardElement(deal.card);
                        finalCard.style.position = 'absolute'; // Asegurar que la carta final se pueda posicionar
                        targetHandElement.appendChild(finalCard); // A√±adir la carta final est√°tica
                        applyFanEffect(); // Re-aplicar el abanico para un efecto progresivo
                        resolve();
                    }, { once: true });
                }, 50);
            });
        }

        function applyFanEffect() {
            const hands = document.querySelectorAll('.player-cards-hand, #dealerCards');

            hands.forEach(hand => {
                // Asegurarse de que el contenedor de la mano tenga posici√≥n relativa
                hand.style.position = 'relative';
                // Y una altura m√≠nima para que no colapse si solo tiene elementos absolutos
                if (hand.querySelectorAll('.card').length > 0) {
                    hand.style.minHeight = '120px'; // Altura aprox. de una carta
                } else {
                    hand.style.minHeight = 'auto'; // Resetear si no hay cartas
                }

                const cards = hand.querySelectorAll('.card');
                const total = cards.length;
                if (total === 0) return;

                const maxAngle = 20; // √Ångulo m√°ximo de rotaci√≥n
                const horizontalSpread = window.innerWidth < 568 ? 20 : 30; // Separaci√≥n de cartas responsive
                const totalWidth = (total - 1) * horizontalSpread;

                cards.forEach((card, index) => {
                    const pivotIndex = (total - 1) / 2;
                    let angle = 0;
                    if (total > 1 && pivotIndex > 0) {
                        angle = (index - pivotIndex) * (maxAngle / pivotIndex);
                    }
                    const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);
                    
                    card.style.left = '50%';
                    card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
                });
            });
        }

        // === FUNCIONES DE APUESTA ===

        function updateBetDisplay() {
            balanceEl.textContent = `$${currentBalance}`;
            totalBetEl.textContent = `$${currentBet}`;
        }

        function updateBettingControls() {
            if (betConfirmed || gameState === 'playing' || gameState === 'finished') {
                disableAllBettingControls();
            } else {
                enableBettingControls();
            }
        }

        function enableBettingControls() {
            bettingArea.classList.remove('betting-controls-disabled');
            document.querySelectorAll('.chips .chip, .betting-area button').forEach(el => {
                el.style.pointerEvents = 'auto';
                el.style.opacity = '1';
                if (el.tagName === 'BUTTON') el.disabled = false;
            });
        }

        function disableAllBettingControls() {
            bettingArea.classList.add('betting-controls-disabled');
            document.querySelectorAll('.chips .chip, .betting-area button').forEach(el => {
                el.style.pointerEvents = 'none';
                el.style.opacity = '0.4';
                if (el.tagName === 'BUTTON') el.disabled = true;
            });
        }

        function placeBet(amount) {
            if (betConfirmed || gameState !== 'betting') {
                alert('No se pueden hacer apuestas en este momento');
                return;
            }
            
            const newBet = currentBet + amount;
            if (newBet > currentBalance) {
                alert("No tienes suficiente saldo para esa apuesta.");
                return;
            }
            
            currentBet = newBet;
            updateBetDisplay();
            window.socket.emit('playerBet', { bet: currentBet });
        }

        function clearBet() {
            if (betConfirmed) return;
            // Usar el evento espec√≠fico del servidor para cancelar la apuesta.
            window.socket.emit('cancelBet');
        }

        function maxBet() {
            if (betConfirmed) return;
            currentBet = currentBalance; // Todo el saldo disponible
            updateBetDisplay();
            window.socket.emit('playerBet', { bet: currentBet });
        }

        function confirmBet() {
            if (currentBet === 0) {
                alert("Debes realizar una apuesta antes de confirmar.");
                return;
            }
            
            if (betConfirmed) {
                alert("Ya confirmaste tu apuesta.");
                return;
            }

            // Confirmar en el servidor
            window.socket.emit('playerConfirmBet');
            console.log(`Confirmando apuesta de $${currentBet}`);

            // Ocultar el modal inmediatamente para este jugador
            bettingArea.style.display = 'none';
        }

        // === FUNCIONES DE UTILIDAD ===

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function showBettingTimer(duration) {
            // Opcional: implementar countdown visual
            console.log(`Tiempo restante para apostar: ${duration/1000} segundos`);
        }

        async function exitRoom() {
            if (confirm('¬øSeguro que quieres salir de la mesa?')) {
                try {
                    showNotification('Saliendo de la mesa...', 'info');
                    
                    // Notificar al servidor que el jugador est√° saliendo.
                    // El servidor se encargar√° de actualizar el conteo y el estado de la mesa.
                    await fetch('/salir-mesa', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ codigo: roomCode })
                    });

                } catch (error) {
                    console.error('Error al notificar al servidor sobre la salida:', error);
                } finally {
                    // Redirigir a la p√°gina de inicio, independientemente de si la llamada a la API tuvo √©xito.
                    // La desconexi√≥n del socket tambi√©n limpiar√° al jugador en el servidor como respaldo.
                    window.location.href = '/';
                }
            }
        }

        // Inicializar
        updateBetDisplay();
    </script>

</body>

</html>