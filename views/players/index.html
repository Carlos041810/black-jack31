<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blackjack Online -Player</title>

    <!-- Favicon personalizado -->
    <link rel="icon" type="image/png" href="/img/logo.png">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- Google Font para un estilo m√°s moderno -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/header.css">
    <link rel="stylesheet" href="/css/players.css">
</head>

<body>
    <div id="notification-container"></div>
    <!-- El header reutilizable se insertar√° aqu√≠ desde el servidor -->

    <!-- Animaci√≥n de cartas flotantes -->
    <div class="floating-cards card-1">‚ô¶</div>
    <div class="floating-cards card-2">‚ô†</div>
    <div class="floating-cards card-3">‚ô•</div>
    <div class="floating-cards card-4">‚ô£</div>



    <!-- √ÅREA DE JUEGO PRINCIPAL -->
    <div class="game-area">
        <!-- √ÅREA DEL DEALER (ARRIBA) -->
        <div class="dealer-area">
            <!-- La pila de cartas (baraja) -->
            <div class="deck-pile" title="Baraja de cartas">
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
                <div class="card card-back"></div>
            </div>
            <div class="dealer-hand" id="dealerCards">
                <!-- Las cartas del dealer se renderizar√°n aqu√≠ -->
            </div>
        </div>

        <!-- SVG DECORATIVO (CENTRO) -->
        <div class="svg-container">
            <svg viewBox="0 0 1000 400" style="width: 100%; height: 300px;">
                <defs>
                    <!-- Curvas corregidas para que el texto no se corte -->
                    <path id="curve-top" d="M 100 150 Q 500 220 900 150" />
                    <path id="curve-bottom" d="M 100 200 Q 500 270 900 200" />
                    <path id="curve-middle" d="M 100 213 Q 500 283 900 213" />

                    <!-- Efectos de sombra -->
                    <filter id="shadow">
                        <feDropShadow dx="3" dy="3" stdDeviation="3" flood-color="#000" flood-opacity="0.5" />
                    </filter>
                </defs>

                <!-- L√≠nea decorativa visible que sigue la curva del texto -->
                <use href="#curve-middle" stroke="#D4AF37" stroke-width="4" fill="none" filter="url(#shadow)" />

                <!-- Texto superior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="56"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-top" startOffset="50%">
                        BLACKJACK 31 PAYS 3 TO 2
                    </textPath>
                </text>

                <!-- Texto inferior -->
                <text font-family="Times New Roman, serif" font-weight="bold" fill="#D4AF37" font-size="36"
                    text-anchor="middle" filter="url(#shadow)">
                    <textPath href="#curve-bottom" startOffset="50%">
                        DEALER MUST STAND ON 27 AND DRAW TO 26
                    </textPath>
                </text>
            </svg>
        </div>
        <!-- √ÅREA DEL JUGADOR (ABAJO) -->
        <div class="player-area">
            <div class="player-cards" id="playerCards">
                <!-- Los jugadores se renderizar√°n aqu√≠ din√°micamente -->
                <div class="waiting-message">Esperando jugadores...</div>
            </div>
        </div>
    </div>

    <!-- √ÅREA DE APUESTAS -->
    <div class="betting-area" id="bettingArea" style="display: none;">
        <div class="betting-modal-content">
            <div class="betting-info-header">
                <div class="balance-info">Balance<br><span id="balance">$100</span></div>
                <div>Total Bet<br><span id="totalBet">$0</span></div>
            </div>
            <div class="chips">
                <img src="/img/10-chip.png" class="chip" alt="Ficha de 10" onclick="placeBet(10)">
                <img src="/img/25-chip.png" class="chip" alt="Ficha de 25" onclick="placeBet(25)">
                <img src="/img/50-chip.png" class="chip" alt="Ficha de 50" onclick="placeBet(50)">
                <img src="/img/100-chip.png" class="chip" alt="Ficha de 100" onclick="placeBet(100)">
            </div>
            <div class="betting-buttons">
                <button onclick="clearBet()">CLEAR</button>
                <button id="confirmBetBtn" onclick="confirmBet()">CONFIRM BET</button>
            </div>
        </div>
    </div>

    <!-- √ÅREA DE ACCIONES DEL JUGADOR -->
    <div class="player-actions" id="playerActions" style="display: none;">
        <button id="hitBtn" class="action-btn hit">Pedir</button>
        <button id="standBtn" class="action-btn stand">Plantarse</button>
    </div>

    <!-- Bot√≥n para reabrir el modal de resultados -->
    <div id="viewResultsContainer"
        style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 100;">
        <button id="viewResultsBtn" class="action-btn" style="background: #8e44ad;">Ver Resultados</button>
    </div>

    <!-- Modal de Fin de Ronda -->
    <div id="endRoundModal" class="end-round-modal" style="display: none;">
        <div class="end-round-modal-content">
            <span class="close-button"
                onclick="document.getElementById('endRoundModal').style.display='none'">&times;</span>
            <h2 id="endRoundModalTitle" style="padding-bottom: 10px ;">Resultados</h2>
            <div id="endRoundModalBody">
                <p>Esperando que el dealer inicie la siguiente ronda.</p>
            </div>
            <button class="action-btn stand" style="margin-top: 20px; background: #7f8c8d;"
                onclick="document.getElementById('endRoundModal').style.display='none'">Cerrar</button>
        </div>
    </div>

    <!-- Librer√≠a para el efecto de confeti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/header.js"></script>
    <script>
        // Variables globales
        window.socket = io();
        let currentBalance = 100;
        let currentBet = 0;
        let betConfirmed = false;
        let gameState = 'waiting';
        let currentPlayerName = '';
        let playersList = []; // Lista de jugadores para referencia
        let roomCode = '';
        let confettiInterval = null; // Variable para controlar la lluvia de confeti

        const balanceEl = document.getElementById('balance');
        const totalBetEl = document.getElementById('totalBet');
        const bettingArea = document.getElementById('bettingArea');

        document.addEventListener('DOMContentLoaded', () => {
            const params = new URLSearchParams(window.location.search);
            roomCode = params.get('codigo');
            currentPlayerName = params.get('nombre');

            // Unirse a la sala
            if (roomCode && window.socket) {
                window.socket.emit('joinRoom', roomCode, currentPlayerName);
            }

            // === EVENT LISTENERS PARA ACCIONES ===
            document.getElementById('hitBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerHit');
                window.socket.emit('playerHit');
            });

            document.getElementById('standBtn').addEventListener('click', () => {
                console.log('-> Emitiendo playerStand');
                window.socket.emit('playerStand');
            });

            // Bot√≥n para ver resultados
            document.getElementById('viewResultsBtn').addEventListener('click', () => {
                document.getElementById('endRoundModal').style.display = 'flex';
            });

            // === EVENTOS DEL SERVIDOR ===

            // Lista de jugadores actualizada
            window.socket.on('updatePlayerList', (players) => {
                console.log('Lista de jugadores actualizada:', players);
                playersList = players; // Guardar la lista globalmente
                renderPlayers(players, currentPlayerName);
                document.getElementById('contador').textContent = players.length;

                // Actualizar nuestro balance si existe en la lista
                const currentPlayer = players.find(p => p.name === currentPlayerName);
                if (currentPlayer) {
                    // El balance puede ser 0, lo cual es un valor v√°lido. No usar '||' para fallback.
                    currentBalance = (currentPlayer.balance !== null && currentPlayer.balance !== undefined) ? currentPlayer.balance : 100;
                    currentBet = currentPlayer.bet || 0;
                    betConfirmed = currentPlayer.betConfirmed || false;
                    updateBetDisplay();
                    updateBettingControls();
                }
            });

            // --- MANEJADOR DE RECONEXI√ìN ---
            window.socket.on('reconnectState', (data) => {
                console.log('üîÑ Recibido estado de reconexi√≥n:', data);
                gameState = data.gameState;
                playersList = data.players;

                // Restaurar estado personal
                currentBalance = data.balance;
                currentBet = data.bet;
                betConfirmed = data.betConfirmed;

                // Actualizar toda la UI
                updateBetDisplay();
                updateBettingControls();
                renderPlayers(data.players, currentPlayerName);

                // Si ya hay cartas, renderizarlas tambi√©n
                if (data.hand && data.hand.length > 0) {
                    console.log('Restaurando manos en la mesa...');
                    // Limpiar manos y puntuaciones previas
                    document.getElementById('dealerCards').innerHTML = '';
                    document.querySelectorAll('.player-cards-hand').forEach(hand => hand.innerHTML = '');
                    document.querySelectorAll('.player-score').forEach(score => score.style.display = 'none');

                    // Renderizar la mano del dealer
                    // Si el juego est√° en 'playing', la mano del dealer puede estar parcialmente oculta.
                    const dealerHandContainer = document.getElementById('dealerCards');
                    const dealerHandToShow = (gameState === 'playing' && data.dealerHand.length > 1)
                        ? [{ hidden: true }, { hidden: true }, data.dealerHand[2]]
                        : data.dealerHand;

                    dealerHandToShow.forEach(cardData => {
                        const cardElement = createCardElement(cardData);
                        cardElement.style.position = 'absolute';
                        dealerHandContainer.appendChild(cardElement);
                    });

                    // Renderizar las manos de todos los jugadores
                    data.players.forEach(player => {
                        if (player.hand && player.hand.length > 0) {
                            const playerHandContainer = document.querySelector(`.player-position[data-player-id="${player.id}"] .player-cards-hand`);
                            if (playerHandContainer) {
                                player.hand.forEach(cardData => {
                                    const cardElement = createCardElement(cardData);
                                    cardElement.style.position = 'absolute';
                                    playerHandContainer.appendChild(cardElement);
                                });
                            }
                        }
                    });

                    applyFanEffect(); // Aplicar el efecto abanico a todas las manos renderizadas
                }
            });

            // Estado del juego actualizado
            window.socket.on('gameStateUpdate', (data) => {
                gameState = data.state;
                console.log('Estado del juego:', gameState);

                // Mostrar/ocultar √°rea de apuestas seg√∫n el estado
                if (gameState === 'betting') {
                    bettingArea.style.display = 'flex';
                    document.getElementById('viewResultsContainer').style.display = 'none';
                } else {
                    bettingArea.style.display = 'none';
                }

                updateBettingControls();
            });

            // Apuestas cerradas
            window.socket.on('bettingClosed', () => {
                console.log('Per√≠odo de apuestas cerrado');
                disableAllBettingControls();
            });

            // Jugador confirm√≥ apuesta
            window.socket.on('playerBetConfirmed', (data) => {
                console.log(`${data.playerName} confirm√≥ apuesta de ${data.bet}$`);
                showNotification(`${data.playerName} confirm√≥ apuesta de ${data.bet}$`);
            });

            // Iniciar juego
            window.socket.on('startGame', () => {
                console.log('¬°Juego iniciado! Todos los jugadores confirmaron sus apuestas');
                showNotification('¬°Juego iniciado! Repartiendo cartas...');
                bettingArea.style.display = 'none';
            });

            // Errores de apuesta
            window.socket.on('betError', (data) => {
                alert('Error en apuesta: ' + data.errors.join(', '));
            });

            // Apuesta actualizada
            window.socket.on('betUpdated', (data) => {
                console.log('Apuesta actualizada a:', data.bet);
            });

            // Apuesta cancelada
            window.socket.on('betCancelled', () => {
                console.log('Apuesta cancelada');
                currentBet = 0;
                updateBetDisplay();
            });

            window.socket.on('turnUpdate', (data) => {
                console.log(`[TURN] Turno de: ${data.playerName}`);
                highlightCurrentPlayerUI(data.playerId, data.playerName);
            });

            window.socket.on('gameReset', () => {
                console.log('üîÑ Juego reiniciado.');
                showNotification('El juego ha sido reiniciado.');
                // Limpiar la mano del dealer
                document.getElementById('dealerCards').innerHTML = '';
                // Limpiar el mensaje de turno. El resto de la UI se limpia con 'updatePlayerList'
                document.getElementById('playerActions').style.display = 'none';
                document.getElementById('viewResultsContainer').style.display = 'none';
                const turnDisplay = document.getElementById('turnDisplay');
                // Limpiar overlays de resultados
                document.querySelectorAll('.result-overlay').forEach(o => o.remove());
                // Limpiar clases de resultado de las cartas
                document.querySelectorAll('.card-lost').forEach(c => {
                    c.classList.remove('card-lost');
                });
                // Limpiar bordes de estado (bust/stand)
                document.querySelectorAll('.busted-card').forEach(c => c.classList.remove('busted-card'));
                document.querySelectorAll('.stood-card').forEach(c => c.classList.remove('stood-card'));
                document.querySelectorAll('.busted').forEach(b => b.classList.remove('busted'));
                // Limpiar bordes de resultado de la ronda anterior
                document.querySelectorAll('.card-win-border, .card-lose-border').forEach(c => {
                    c.classList.remove('card-win-border', 'card-lose-border');
                });
                // --- Detener la lluvia de confeti ---
                if (confettiInterval) {
                    clearInterval(confettiInterval);
                    confettiInterval = null;
                    if (typeof confetti === 'function') confetti.reset();
                }
                const dealerScore = document.querySelector('.dealer-score-display');
                if (dealerScore) dealerScore.remove();
                if (turnDisplay) turnDisplay.remove();

                // Ocultar puntuaciones
                document.querySelectorAll('.player-score').forEach(scoreDiv => {
                    scoreDiv.style.display = 'none';
                });
            });

            // Errores generales
            window.socket.on('error', (data) => {
                alert('Error: ' + data.message);
            });

            // Dealer desconectado
            window.socket.on('dealerDisconnected', () => {
                // Usar un temporizador corto para asegurar que el alert se muestre antes de la redirecci√≥n
                alert('El dealer se ha desconectado. Volviendo al men√∫ principal.');
                setTimeout(() => { window.location.href = '/'; }, 100);
            });

            window.socket.on('cardsDealt', (data) => {
                console.log('üÉè Recibiendo cartas del servidor:', data);

                // Limpiar puntuaciones anteriores
                document.querySelectorAll('.player-score').forEach(scoreDiv => {
                    scoreDiv.style.display = 'none';
                });

                // Limpiar manos actuales antes de repartir
                document.getElementById('dealerCards').innerHTML = '';
                document.querySelectorAll('.player-cards-hand').forEach(hand => {
                    hand.innerHTML = '';
                });

                // Ocultar √°rea de apuestas y deshabilitar controles
                bettingArea.style.display = 'none';
                // Ocultar botones de acci√≥n al repartir, se mostrar√°n cuando sea el turno
                document.getElementById('playerActions').style.display = 'none';

                // Para los jugadores, las dos primeras cartas del dealer est√°n ocultas y la tercera es visible.
                // Esta es la mano que se usar√° para la animaci√≥n.
                const dealerHandForAnimation = [
                    { hidden: true },   // Primera carta oculta
                    { hidden: true },   // Segunda carta oculta
                    data.dealer[2]      // Tercera carta visible
                ];

                animateDealing(data.players, dealerHandForAnimation);

                // Actualizar la puntuaci√≥n de cada jugador
                setTimeout(() => {
                    data.players.forEach(player => {
                        const scoreDiv = document.getElementById(`player-score-${player.id}`);
                        if (scoreDiv && player.id === window.socket.id) { // Mostrar solo para el jugador principal
                            scoreDiv.textContent = `Puntos: ${player.score}`;
                            scoreDiv.style.display = 'block';
                        }
                    });
                }, 1800); // Retraso para que aparezca despu√©s de la animaci√≥n
            });

            // Un jugador (o yo) recibe una nueva carta
            window.socket.on('playerCardUpdate', (data) => {
                console.log(`[CARD UPDATE] Jugador ${data.playerId} recibe una carta.`);

                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'player',
                    id: data.playerId,
                    card: data.newCard,
                };
                // Animar solo la nueva carta que se reparte
                dealOneCard(dealInfo, deckRect);

                // Actualizar la puntuaci√≥n si soy yo
                if (data.playerId === window.socket.id) {
                    const scoreDiv = document.getElementById(`player-score-${data.playerId}`);
                    if (scoreDiv) {
                        scoreDiv.textContent = `Puntos: ${data.score}`;
                    }
                }
            });

            // Un jugador se pasa de 21
            window.socket.on('playerBust', (data) => {
                console.log(`[BUST] ${data.playerName} se ha pasado.`);
                showNotification(`${data.playerName} se pas√≥ con ${data.score}!`, 'error');
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    const cardsInHand = playerDiv.querySelectorAll('.player-cards-hand .card');
                    cardsInHand.forEach(card => {
                        card.classList.add('busted-card');
                    });
                    // Actualizar el display de informaci√≥n del jugador
                    const infoDisplay = playerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `<strong>${data.playerName}</strong>&nbsp;se pas√≥ de 31`;
                        infoDisplay.classList.add('status-bust');
                    }
                }
                // Si soy yo quien se ha pasado, oculto mis botones de acci√≥n y actualizo la puntuaci√≥n.
                if (data.playerId === window.socket.id) {
                    document.getElementById('playerActions').style.display = 'none';
                    const scoreDiv = document.getElementById(`player-score-${data.playerId}`);
                    if (scoreDiv) {
                        scoreDiv.textContent = `Puntos: ${data.score}`;
                    }
                }
            });

            // Un jugador se planta
            window.socket.on('playerStood', (data) => {
                console.log(`[STAND] ${data.playerName}   se ha plantado.`);
                const playerDiv = document.querySelector(`.player-position[data-player-id="${data.playerId}"]`);
                if (playerDiv) {
                    // A√±adir un borde de color a las cartas para indicar que se ha plantado
                    const cardsInHand = playerDiv.querySelectorAll('.player-cards-hand .card');
                    cardsInHand.forEach(card => {
                        card.classList.add('stood-card'); // La clase correcta es 'stood-card'
                    });

                    const infoDisplay = playerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `<strong>${data.playerName}</strong>&nbsp;se plant√≥`;
                        infoDisplay.classList.add('status-stand');
                    }
                }
            });

            // El turno pasa al dealer
            window.socket.on('dealerTurn', () => {
                console.log('[DEALER TURN] Turno del dealer.');
                showNotification('Turno del Dealer. Revelando carta...', 'info');
                // Des-resaltar a todos y mostrar mensaje del dealer
                // El null en playerId se encarga de que no se resalte a nadie
                // y el mensaje se actualice correctamente.
                highlightCurrentPlayerUI(null, 'Dealer');
            });

            // El dealer revela su carta
            window.socket.on('revealDealerCard', (data) => {
                console.log('[DEALER REVEAL] El dealer revela su mano completa:', data.dealerHand);
                const dealerHandContainer = document.getElementById('dealerCards');

                // Limpiar la mano actual del dealer (que contiene cartas ocultas)
                dealerHandContainer.innerHTML = '';

                // Renderizar la mano completa del dealer con todas las cartas visibles
                data.dealerHand.forEach(cardData => {
                    const cardElement = createCardElement(cardData);
                    cardElement.style.position = 'absolute'; // Necesario para el efecto abanico
                    dealerHandContainer.appendChild(cardElement);
                });

                applyFanEffect(); // Re-aplicar el efecto abanico para ajustar las posiciones
            });

            // El dealer pide una carta (Hit)
            window.socket.on('dealerCardUpdate', (data) => {
                console.log(`[DEALER HIT] Dealer recibe una carta.`);

                const deckElement = document.querySelector('.deck-pile');
                if (!deckElement) return;
                const deckRect = deckElement.getBoundingClientRect();

                const dealInfo = {
                    target: 'dealer',
                    card: data.newCard,
                };
                // Animar la carta que pide el dealer
                dealOneCard(dealInfo, deckRect);
            });

            // Resultados del juego
            window.socket.on('gameResults', (data) => {
                console.log('[RESULTS] Resultados recibidos:', data);
                showNotification('Ronda finalizada. Mostrando resultados...', 'success');
                addResultStyles(); // Asegurarse de que los estilos existan

                // Ocultar el mensaje de turno y los botones de acci√≥n
                const turnDisplay = document.getElementById('turnDisplay');
                if (turnDisplay) turnDisplay.style.display = 'none';
                document.getElementById('playerActions').style.display = 'none';

                // Mostrar el bot√≥n para ver resultados
                document.getElementById('viewResultsContainer').style.display = 'block';

                data.results.forEach(result => {
                    // L√≥gica para colorear bordes de cartas del jugador y dealer
                    if (result.playerId === window.socket.id) {
                        const playerWin = result.outcome === 'WIN' || result.outcome === 'BLACKJACK';
                        const playerLose = result.outcome === 'LOSE';

                        const myPlayerDiv = document.querySelector(`.player-position[data-player-id="${window.socket.id}"]`);
                        const dealerHandContainer = document.getElementById('dealerCards');

                        if (myPlayerDiv && dealerHandContainer) {
                            const myCards = myPlayerDiv.querySelectorAll('.player-cards-hand .card');
                            const dealerCards = dealerHandContainer.querySelectorAll('.card');

                            if (playerWin) {
                                myCards.forEach(c => c.classList.add('card-win-border'));
                                dealerCards.forEach(c => c.classList.add('card-lose-border'));
                            } else if (playerLose) {
                                myCards.forEach(c => c.classList.add('card-lose-border'));
                                dealerCards.forEach(c => c.classList.add('card-win-border'));
                            }
                            // No se aplica borde especial en caso de PUSH (empate)
                        }
                    }



                    const playerDiv = document.querySelector(`.player-position[data-player-id="${result.playerId}"]`);
                    if (playerDiv) {
                        // Se ha eliminado la creaci√≥n del overlay de resultado (WIN/PUSH/etc.)

                        // Actualizar nuestro propio balance
                        if (result.playerId === window.socket.id) {
                            currentBalance = result.newBalance;
                            updateBetDisplay();
                        }
                    }
                });

                // Mostrar la puntuaci√≥n final del dealer
                const dealerHandContainer = document.getElementById('dealerCards');
                // Remover score display anterior si existe
                const oldScoreDisplay = dealerHandContainer.querySelector('.dealer-score-display');
                if (oldScoreDisplay) oldScoreDisplay.remove();

                const dealerScoreDisplay = document.createElement('div');
                dealerScoreDisplay.className = 'dealer-score-display';
                let dealerText = `Puntuaci√≥n del Dealer: ${data.dealerScore}`;
                if (data.dealerScore > 31) {
                    dealerText += ' (BUST)';
                } else if (data.dealerScore === 31 && document.getElementById('dealerCards').querySelectorAll('.card').length === 2) {
                    dealerText += ' (BLACKJACK)';
                }
                dealerScoreDisplay.textContent = dealerText;
                dealerHandContainer.appendChild(dealerScoreDisplay);

                // Abrir el modal de fin de ronda despu√©s de 3 segundos
                setTimeout(() => {
                    const modal = document.getElementById('endRoundModal');
                    const modalTitle = document.getElementById('endRoundModalTitle');
                    const modalBody = document.getElementById('endRoundModalBody');
                    modalTitle.style.textAlign = 'center'; // Centrar el t√≠tulo

                    // --- L√≥gica para personalizar el t√≠tulo del modal ---
                    const myResult = data.results.find(r => r.playerId === window.socket.id);
                    if (myResult) {
                        // Quitar animaciones previas si las hay
                        modalTitle.classList.remove('modal-anim-win', 'modal-anim-lose', 'modal-anim-push');
                        switch (myResult.outcome) {
                            case  'WIN':
                            case 'BLACKJACK':
                                modalTitle.textContent = '¬°Ganaste!';
                                modalTitle.style.color = '#27ae60';
                                modalTitle.classList.add('modal-anim-win');
                                if (confettiInterval) clearInterval(confettiInterval);
                                if (typeof confetti === 'function') {
                                    confettiInterval = setInterval(() => {
                                        confetti({
                                            particleCount: 6,
                                            startVelocity: 8,
                                            spread: 70,
                                            ticks: 600,
                                            origin: { x: Math.random(), y: 0 },
                                            gravity: 0.8,
                                            scalar: 1,
                                            colors: ['#27ae60', '#2ecc71', '#D4AF37', '#F4E678'],
                                            zIndex: 1600
                                        });
                                    }, 200);
                                }
                                break;
                            case 'LOSE':
                                modalTitle.textContent = 'Perdiste';
                                modalTitle.style.color = '#c0392b';
                                modalTitle.classList.add('modal-anim-lose');
                                if (confettiInterval) clearInterval(confettiInterval);
                                if (typeof confetti === 'function') {
                                    confettiInterval = setInterval(() => {
                                        confetti({
                                            particleCount: 6,
                                            startVelocity: 8,
                                            spread: 70,
                                            ticks: 600,
                                            origin: { x: Math.random(), y: 0 },
                                            gravity: 0.8,
                                            scalar: 1,
                                            colors: ['#e74c3c', '#c0392b', '#a93226', '#ff6b6b'],
                                            zIndex: 1600
                                        });
                                    }, 200);
                                }
                                break;
                            case 'PUSH':
                                modalTitle.textContent = '¬°Empate!';
                                modalTitle.style.color = '#2980b9';
                                modalTitle.classList.add('modal-anim-push');
                                if (confettiInterval) clearInterval(confettiInterval);
                                if (typeof confetti === 'function') {
                                    confettiInterval = setInterval(() => {
                                        confetti({
                                            particleCount: 6,
                                            startVelocity: 8,
                                            spread: 70,
                                            ticks: 600,
                                            origin: { x: Math.random(), y: 0 },
                                            gravity: 0.8,
                                            scalar: 1,
                                            colors: ['#3498db', '#2980b9', '#5dade2', '#85c1e9'],
                                            zIndex: 1600
                                        });
                                    }, 200);
                                }
                                break;
                        }
                    }
                    // --- Animaciones CSS para el t√≠tulo del modal ---
                    if (!document.getElementById('modal-anim-styles')) {
                        const style = document.createElement('style');
                        style.id = 'modal-anim-styles';
                        style.innerHTML = `
                            .modal-anim-win, .modal-anim-lose, .modal-anim-push {
                                animation: modal-breath 1.3s cubic-bezier(.4,0,.2,1) infinite;
                            }
                            @keyframes modal-breath {
                                0% { transform: scale(1); }
                                30% { transform: scale(1.18); }
                                50% { transform: scale(1.08); }
                                70% { transform: scale(1.18); }
                                100% { transform: scale(1); }
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    // Funci√≥n para determinar el resultado general del dealer
                    function getDealerOutcome(myResult) {
                        // Si no hay un resultado para el jugador actual (por ejemplo, si es un espectador),
                        // el dealer se muestra como neutral (PUSH).
                        if (!myResult) {
                            return 'PUSH';
                        }
                        // El resultado del dealer es el opuesto al del jugador.
                        switch (myResult.outcome) {
                            case 'WIN':
                            case 'BLACKJACK':
                                return 'LOSE'; // Si yo gano, el dealer pierde.
                            case 'LOSE':
                                return 'WIN'; // Si yo pierdo, el dealer gana.
                            case 'PUSH':
                                return 'PUSH'; // Si empatamos, es un empate.
                            default:
                                return 'PUSH';
                        }
                    }

                    // 1. Crear una lista combinada de jugadores y el dealer
                    const allParticipants = [
                        ...data.results.map(r => ({ ...r, type: 'player' })),
                        {
                            playerName: 'Dealer',
                            playerScore: data.dealerScore,
                            type: 'dealer',
                            outcome: getDealerOutcome(myResult) // Asignar resultado al dealer basado en mi resultado
                        }
                    ];

                    // 2. Ordenar la lista: ganadores primero, luego el dealer, luego perdedores/empates.
                    allParticipants.sort((a, b) => {
                        const outcomeA = a.outcome; // 'WIN', 'BLACKJACK', 'LOSE', 'PUSH'
                        const outcomeB = b.outcome;

                        // Prioridad para ganadores
                        const aWins = outcomeA === 'WIN' || outcomeA === 'BLACKJACK';
                        const bWins = outcomeB === 'WIN' || outcomeB === 'BLACKJACK';

                        if (aWins && !bWins) return -1;
                        if (!aWins && bWins) return 1;

                        // Si ambos ganan o ambos no ganan, ordenar por puntuaci√≥n (el m√°s alto primero)
                        // Los que se pasan (bust) van al final.
                        const scoreA = a.playerScore > 31 ? -1 : a.playerScore;
                        const scoreB = b.playerScore > 31 ? -1 : b.playerScore;

                        return scoreB - scoreA;
                    });

                    // 3. Crear el HTML para la lista de puntuaciones

                    let resultsHtml = `<div class="results-list">`;
                    allParticipants.forEach(participant => {
                        let rowClass = participant.type === 'dealer' ? 'results-row dealer-row' : 'results-row';
                        const outcome = participant.outcome;
                        if (outcome === 'WIN' || outcome === 'BLACKJACK') {
                            rowClass += ' winner-row';
                        } else if (outcome === 'LOSE') {
                            rowClass += ' loser-row';
                        } else if (outcome === 'PUSH') {
                            rowClass += ' push-row';
                        }
                        // Resaltar SOLO al jugador actual seg√∫n su resultado
                        if (participant.playerId === window.socket.id) {
                            if (outcome === 'WIN' || outcome === 'BLACKJACK') {
                                rowClass += ' current-player-win';
                            } else if (outcome === 'PUSH') {
                                rowClass += ' current-player-push';
                            } else if (outcome === 'LOSE') {
                                rowClass += ' current-player-lose';
                            }
                        }
                        resultsHtml += `
                            <div class="${rowClass}" style="transition: all 0.3s ease;">
                                <span>${participant.playerName}</span>
                                <span>${participant.playerScore > 31 ? `Se pas√≥ (${participant.playerScore})` : participant.playerScore}</span>
                            </div>
                        `;
                    });
                    resultsHtml += '</div>';

                    // --- TEXTO PERSONALIZADO DE GANADOR(ES) ---
                    const winners = allParticipants.filter(p => (p.outcome === 'WIN' || p.outcome === 'BLACKJACK') && p.type === 'player');
                    let winnerText = '';
                    if (winners.length === 1) {
                        winnerText = `${winners[0].playerName} ha ganado la ronda`;
                    } else if (winners.length === 2) {
                        winnerText = `${winners[0].playerName} y ${winners[1].playerName} han ganado la ronda`;
                    }
                    if (winnerText) {
                        resultsHtml += `<p class="waiting-next-round">${winnerText}</p><p class="waiting-next-round">Esperando que el dealer inicie la siguiente ronda...</p>`;
                    } else {
                        resultsHtml += '<p class="waiting-next-round">Esperando que el dealer inicie la siguiente ronda...</p>';
                    }

                    // 3. Actualizar el contenido del modal y mostrarlo
                    if (modal && modalBody) {
                        modalBody.innerHTML = resultsHtml; // Corregido: modalBody
                        modal.style.display = 'flex';
                    }
                }, 2000); // 2s para dar tiempo a ver los resultados en mesa
            });
        });

        // === FUNCIONES DE RENDERIZADO ===

        function renderPlayers(players, currentPlayerName) {
            const playerCardsContainer = document.getElementById('playerCards');
            playerCardsContainer.innerHTML = '';

            if (players.length === 0) {
                playerCardsContainer.innerHTML = '<div class="waiting-message">Esperando jugadores...</div>';
                return;
            }

            // A√±adir clase espec√≠fica para un solo jugador
            if (players.length === 1) {
                playerCardsContainer.classList.add('single-player-layout');
            } else {
                playerCardsContainer.classList.remove('single-player-layout');
            }

            if (players.length === 2) {
                // Caso especial para 2 jugadores: apilados y centrados con Flexbox
                playerCardsContainer.classList.add('two-players');

                const currentPlayer = players.find(p => p.name === currentPlayerName);
                const otherPlayer = players.find(p => p.name !== currentPlayerName);

                // Renderizar al otro jugador primero (arriba), luego al jugador actual (abajo)
                [otherPlayer, currentPlayer].forEach((player) => {
                    if (!player) return;

                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'player-position'; // Sin clases de posicionamiento absoluto
                    playerDiv.dataset.playerId = player.id;

                    let betDisplay = '';
                    let betStatusClass = '';

                    if (player.bet > 0) {
                        const chipStack = getChipStackHtml(player.bet);
                        betStatusClass = player.betConfirmed ? 'bet-confirmed' : 'bet-pending';
                        betDisplay = `${chipStack}`;
                    } else {
                        betDisplay = ``; // No mostrar nada si no hay apuesta
                        betStatusClass = 'no-bet';
                    }

                    playerDiv.innerHTML = `
                        <div class="player-content">
                            <div class="player-info-display">${player.name}</div>
                            <div class="player-bet ${betStatusClass}">${betDisplay}</div>
                            <div class="player-cards-hand"></div>
                            <div class="player-score" id="player-score-${player.id}" style="display: none; color: white; font-weight: bold;"></div>
                        </div>`;

                    playerCardsContainer.appendChild(playerDiv);
                });

            } else {
                // L√≥gica para 1 o m√°s de 2 jugadores
                playerCardsContainer.classList.remove('two-players');
                const reorderedPlayers = [...players];
                const currentPlayerOriginalIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

                if (currentPlayerOriginalIndex > -1) {
                    const [currentPlayer] = reorderedPlayers.splice(currentPlayerOriginalIndex, 1);
                    const middleIndex = Math.floor(reorderedPlayers.length / 2);
                    reorderedPlayers.splice(middleIndex, 0, currentPlayer);
                }

                const centerIndex = reorderedPlayers.findIndex(p => p.name === currentPlayerName);

                reorderedPlayers.forEach((player, index) => {
                    const playerDiv = document.createElement('div');
                    let positionClass = '';

                    if (index === centerIndex) {
                        positionClass = 'curve-center';
                    } else if (centerIndex !== -1 && index < centerIndex) {
                        positionClass = 'curve-left';
                    } else {
                        positionClass = 'curve-right';
                    }

                    playerDiv.className = `player-position ${positionClass}`;
                    playerDiv.dataset.playerId = player.id;

                    let betDisplay = '';
                    let betStatusClass = '';

                    if (player.bet > 0) {
                        const chipStack = getChipStackHtml(player.bet);
                        betStatusClass = player.betConfirmed ? 'bet-confirmed' : 'bet-pending';
                        betDisplay = `${chipStack}`;
                    } else {
                        betDisplay = ``; // No mostrar nada si no hay apuesta
                        betStatusClass = 'no-bet';
                    }

                    playerDiv.innerHTML = `
                        <div class="player-content">
                            <div class="player-info-display">${player.name}</div>
                            <div class="player-bet ${betStatusClass}">${betDisplay}</div>
                            <div class="player-cards-hand"></div>
                            <div class="player-score" id="player-score-${player.id}" style="display: none; color: white; font-weight: bold;"></div>
                        </div>`;

                    playerCardsContainer.appendChild(playerDiv);
                });
            }

            // Agregar estilos si no existen
            addPlayerStyles();
        }

        function addPlayerStyles() {
            if (!document.getElementById('player-bet-styles')) {
                const style = document.createElement('style');
                style.id = 'player-bet-styles';
                style.innerHTML = `
                    .player-score {
            position:relative; bottom:-115px; left:37%;
            transform:translateX(-50%); color:#FFD700;
            font-size:1.3em; font-weight:bold; text-align:center;
                    }   
                    .player-bet .chip-stack {
                        position: relative;
                        display: inline-block;
                        width: 30px;
                        height: 40px; /* Espacio para la pila */
                        vertical-align: middle;
                        margin-right: 5px;
                    }
                    .player-bet .stacked-chip {
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        width: 30px;
                        height: 30px;
                        transition: transform 0.2s;
                    }
                    .player-bet .bet-total-text {
                        vertical-align: middle;
                    }
                    .player-bet.bet-confirmed .bet-total-text { color: #27ae60; }
                    .player-bet.bet-pending .bet-total-text { color: #f39c12; }


                    #notification-container {
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        z-index: 2000;
                    }

                    .notification {
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        animation: slideIn 0.5s ease;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                    }

                    .notification.success { background: #27ae60; }
                    .notification.error { background: #e74c3c; }
                    .notification.info { background: #3498db; }
                    
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }

                    .player-info-display {
                        color: white;
                        font-weight: bold;
                        margin-bottom: 8px;
                        height: 2.5em; /* Altura fija para evitar saltos de layout */
                        text-align: center;
                        min-width: 150px; /* Ancho m√≠nimo para evitar que el texto cambie el tama√±o */
                    }

                    .player-position {
                        position: relative;
                        overflow: visible;
                        margin: 10px;
                        padding: 10px;
                        border-radius: 10px;
                        border: 2px solid transparent;
                        transition: all 0.3s ease;
                    }
                    .player-content {
                        transition: transform 0.3s ease;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 10px;
                    }
                    .player-position.current-turn .player-content {
                        transform: scale(1.05);
                    }
                    .player-info-display.status-bust {
                        color: #e74c3c;
                    }
                    .player-info-display.status-stand {
                        color: #3498db;
                    }

                    /* --- JERARQU√çA DE ESTILOS DE BORDE --- */
                    
                    /* 1. Turno Actual (Prioridad Baja) */
                    .player-position.current-turn .card {
                        border: 3px solid #4eb8ff !important;
                        box-shadow: 0 0 12px rgba(78, 184, 255, 0.8) !important;
                    }

                    /* 2. Plantado (Prioridad Media) - Sobrescribe al turno actual */
                    .player-position .card.stood-card {
                        border: 3px solid #3498db !important;
                        box-shadow: 0 0 10px rgba(52, 152, 219, 0.7) !important;
                    }

                    /* 3. Pasado (Prioridad M√°xima) - Sobrescribe a todos los dem√°s */
                    .player-position .card.busted-card {
                        border: 3px solid #e74c3c !important;
                        box-shadow: 0 0 12px rgba(231, 76, 60, 0.8) !important;
                    }

                    /* 4. Resultado de la Ronda (Prioridad M√°xima) */
                    .player-position .card.card-win-border,
                    .dealer-hand .card.card-win-border {
                        border: 4px solid #2ecc71 !important;
                        box-shadow: 0 0 15px rgba(46, 204, 113, 0.9) !important;
                    }

                    .player-position .card.card-lose-border,
                    .dealer-hand .card.card-lose-border {
                        border: 4px solid #e74c3c !important;
                        box-shadow: 0 0 15px rgba(231, 76, 60, 0.9) !important;
                    }

                    /* Estilos para la puntuaci√≥n final del dealer */
                    .dealer-score-display {
                        position: absolute;
                        bottom: -40px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: #FFD700;
                        padding: 8px 18px;
                        border-radius: 12px;
                        font-weight: bold;
                        white-space: nowrap;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                        z-index: 10; /* Asegura que est√© por encima de las cartas */
                    }

                    /* Estilos para la lista de resultados en el modal */
                    .results-list { width: 100%; margin-bottom: 20px; }
                    .results-header, .results-row {
                        display: flex;
                        justify-content: space-between;
                        padding: 10px 15px;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    }
                    .results-header {
                        font-weight: bold;
                        color: #D4AF37;
                        background: rgba(255, 255, 255, 0.05);
                        border-top-left-radius: 8px;
                        border-top-right-radius: 8px;
                    }
                    .results-row.dealer-row {
                        color: #FFD700; /* Mantenemos el color del texto dorado */
                        font-weight: bold;
                    }
                    .results-row span:last-child {
                        font-weight: bold;
                    }
                    .waiting-next-round {
                        text-align: center;
                        font-style: italic;
                        margin-top: 15px;
                        color: #ccc;
                    }
                    .end-round-modal-content {
                        font-family: 'Poppins', sans-serif;
                    }
                    .winner-row {
                        background: linear-gradient(90deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.1));
                        color: #f5f5f5 !important;
                        border-left: 4px solid #27ae60;
                        border-radius: 8px;
                    }
                    .loser-row {
                        background: linear-gradient(90deg, rgba(192, 57, 43, 0.25), rgba(192, 57, 43, 0.05));
                        color: #a0a0a0 !important;
                        border-left: 4px solid #c0392b;
                        border-radius: 8px;
                        opacity: 0.8;
                    }
                    .push-row {
                        background: linear-gradient(90deg, rgba(41, 128, 185, 0.25), rgba(41, 128, 185, 0.05));
                        color: #bdc3c7 !important;
                        border-left: 4px solid #2980b9;
                        border-radius: 8px;
                    }
                    .current-player-win {
                        border: 2.5px solid #27ae60 !important;
                        background: linear-gradient(90deg, rgba(39, 174, 96, 0.18), rgba(39, 174, 96, 0.05));
                        font-weight: bold;
                        transform: scale(1.05) !important;
                    }
                    .current-player-push {
                        border: 2.5px solid #2980b9 !important;
                        background: linear-gradient(90deg, rgba(41, 128, 185, 0.18), rgba(41, 128, 185, 0.05));
                        font-weight: bold;
                        transform: scale(1.05) !important;
                    }
                    .current-player-lose {
                        border: 2.5px solid #c0392b !important;
                        background: linear-gradient(90deg, rgba(192, 57, 43, 0.18), rgba(192, 57, 43, 0.05));
                        font-weight: bold;
                        transform: scale(1.05) !important;
                    }

                    .bet-confirmed-icon {
                        color: #27ae60;
                        font-size: 1.2em;
                        margin-top: 5px;
                        display: flex;
                        align-items: center;
                        gap: 5px;
                    }
                    
                    .bet-pending {
                        color: #f39c12;
                        font-weight: bold;
                        margin-top: 5px;
                    }
                    
                    .no-bet {
                        color: rgba(255, 255, 255, 0.5);
                        margin-top: 5px;
                    }
                    
                    @keyframes pulse {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.1); }
                        100% { transform: scale(1); }
                    }
                    
                    .betting-controls-disabled .chip,
                    .betting-controls-disabled button {
                        pointer-events: none !important;
                        opacity: 0.4 !important;
                    }
                    
                    .dealing-animation {
                        position: fixed;
                        z-index: 2000;
                        transition: all 0.6s cubic-bezier(0.25, 1, 0.5, 1);
                        transform-origin: center center;
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function addResultStyles() {
            if (document.getElementById('game-result-styles')) return;
            const style = document.createElement('style');
            style.id = 'game-result-styles';
            style.innerHTML = `
                .result-overlay {
                    position: absolute;
                    top: 0;
                    left: -30px; /* Ensanchar para cubrir el abanico */
                    right: -30px; /* Ensanchar para cubrir el abanico */
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    border-radius: 10px;
                    z-index: 15;
                    text-align: center;
                    animation: fadeIn 0.5s;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                .result-overlay .outcome-text {
                    font-size: 2.5em;
                    font-weight: bold;
                    text-transform: uppercase;
                    text-shadow: 2px 2px 5px #000;
                }
                .result-overlay .score-text {
                    font-size: 1.2em;
                    margin-top: 5px;
                }
            `;
            document.head.appendChild(style);
        }

        function highlightCurrentPlayerUI(playerId, playerName) {

            // 1. Limpiar todos los highlights y mensajes de turno previos
            document.querySelectorAll('.player-position').forEach(div => {
                div.classList.remove('current-turn');
                const infoDisplay = div.querySelector('.player-info-display');

                // Si el texto no es un estado final (plantado/perdido), lo reseteamos al nombre.
                if (infoDisplay && !infoDisplay.classList.contains('status-stand') && !infoDisplay.classList.contains('status-bust')) {
                    const originalPlayerId = div.dataset.playerId;
                    const originalPlayer = playersList.find(p => p.id === originalPlayerId);
                    if (originalPlayer) {
                        infoDisplay.innerHTML = originalPlayer.name;
                    }
                }
            });

            // 2. Determinar si es mi turno y actualizar la UI
            const isMyTurn = window.socket.id === playerId;
            const playerActions = document.getElementById('playerActions');

            if (isMyTurn) {
                // Es mi turno: muestro mis botones de acci√≥n y resalto mi √°rea.
                playerActions.style.display = 'flex';
                const myPlayerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
                if (myPlayerDiv) {
                    myPlayerDiv.classList.add('current-turn');
                    const infoDisplay = myPlayerDiv.querySelector('.player-info-display');
                    if (infoDisplay) {
                        infoDisplay.innerHTML = `Es&nbsp;<strong>tu</strong>&nbsp;turno`;
                    }
                }
            } else {
                // No es mi turno: oculto mis botones.
                playerActions.style.display = 'none';

                if (playerId) { // Es el turno de otro jugador
                    const playerDiv = document.querySelector(`.player-position[data-player-id="${playerId}"]`);
                    if (playerDiv) {
                        playerDiv.classList.add('current-turn');
                        const infoDisplay = playerDiv.querySelector('.player-info-display');
                        // Solo actualizamos si no tiene ya un estado final
                        if (infoDisplay && !infoDisplay.classList.contains('status-stand') && !infoDisplay.classList.contains('status-bust')) {
                            infoDisplay.innerHTML = `Turno de&nbsp;<strong>${playerName}</strong>`;
                        }
                    }
                }
                // Si playerId es null (turno del dealer), no se muestra ning√∫n mensaje en las √°reas de los jugadores.
            }
        }

        // === L√ìGICA DE ANIMACI√ìN DE CARTAS (ID√âNTICA A LA DEL DEALER) ===

        function getChipStackHtml(bet) {
            if (bet <= 0) return '';

            let chipStackHtml = '<div class="chip-stack">';
            let tempBet = bet;
            const chipDenominations = [100, 50, 25, 10];
            let zIndex = 1;
            let offset = 0;
            const maxChipsPerStack = 5; // Para evitar pilas demasiado altas

            for (const denomination of chipDenominations) {
                let count = Math.floor(tempBet / denomination);
                count = Math.min(count, maxChipsPerStack); // Limitar chips por denominaci√≥n
                for (let i = 0; i < count; i++) {
                    chipStackHtml += `<img src="/img/${denomination}-chip.png" class="stacked-chip" style="z-index: ${zIndex}; transform: translateY(-${offset}px);" alt="${denomination}$">`;
                    zIndex++;
                    offset += 4; // Peque√±o desplazamiento para cada ficha
                }
                tempBet -= count * denomination;
            }
            chipStackHtml += '</div>';
            return chipStackHtml;
        }

        function createCardElement(card) {
            const cardDiv = document.createElement('div');

            if (card.hidden) {
                cardDiv.className = 'card card-back';
                return cardDiv;
            }

            // Usar la imagen de la carta como fondo
            cardDiv.className = 'card';
            cardDiv.style.backgroundImage = `url('/${card.src}')`;
            cardDiv.style.backgroundSize = 'cover';
            cardDiv.style.backgroundPosition = 'center';
            cardDiv.style.backgroundRepeat = 'no-repeat';

            return cardDiv;
        }

        async function animateDealing(players, dealerHand) {
            const deckElement = document.querySelector('.deck-pile');
            if (!deckElement) return;

            const deckRect = deckElement.getBoundingClientRect();
            const playersWithBets = players.filter(p => playersList.find(pl => pl.id === p.id && pl.betConfirmed));

            const dealSequence = [];

            // Ronda 1
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[0] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHand[0] }); // Carta de animaci√≥n del dealer

            // Ronda 2
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[1] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHand[1] }); // Carta de animaci√≥n del dealer

            // Ronda 3
            playersWithBets.forEach(player => dealSequence.push({ target: 'player', id: player.id, card: player.hand[2] })); // Carta real del jugador
            dealSequence.push({ target: 'dealer', card: dealerHand[2] }); // Carta de animaci√≥n del dealer

            for (const deal of dealSequence) {
                await dealOneCard(deal, deckRect);
            }
            // Aplicar el efecto abanico una vez que todas las cartas se han repartido
            applyFanEffect();
        }

        function dealOneCard(deal, deckRect) {
            return new Promise(resolve => {
                let targetHandElement;
                if (deal.target === 'player') {
                    targetHandElement = document.querySelector(`.player-position[data-player-id="${deal.id}"] .player-cards-hand`);
                } else {
                    targetHandElement = document.getElementById('dealerCards');
                }

                if (!targetHandElement) {
                    // Si no se encuentra el contenedor, simplemente resolvemos la promesa para no detener la secuencia.
                    console.warn(`No se encontr√≥ el contenedor de mano para ${deal.target} ${deal.id || ''}`);
                    return resolve();
                }

                const cardElement = createCardElement(deal.card);
                cardElement.classList.add('dealing-animation');
                cardElement.style.left = `${deckRect.left}px`;
                cardElement.style.top = `${deckRect.top}px`;
                document.body.appendChild(cardElement);

                const targetRect = targetHandElement.getBoundingClientRect();
                // Apuntar la animaci√≥n al centro del contenedor de la mano para un aterrizaje suave.
                // Restamos la mitad del ancho/alto de la carta para centrarla.
                const cardWidth = 80;
                const cardHeight = 120;
                const targetX = targetRect.left + (targetRect.width / 2) - (cardWidth / 2);
                const targetY = targetRect.top + (targetRect.height / 2) - (cardHeight / 2);

                setTimeout(() => {
                    // Detectar si el jugador est√° en una posici√≥n lateral
                    let isSidePlayer = false;
                    if (deal.target === 'player') {
                        const playerDiv = document.querySelector(`.player-position[data-player-id="${deal.id}"]`);
                        if (playerDiv && (playerDiv.classList.contains('curve-left') || playerDiv.classList.contains('curve-right'))) {
                            isSidePlayer = true;
                        }
                        // A√±adir l√≥gica para 2 jugadores: si el jugador no soy yo, es un "jugador lateral" para la animaci√≥n.
                        if (playersList.length === 2 && deal.id !== window.socket.id) {
                            isSidePlayer = true;
                        }
                    }

                    let finalTransform = `translate(${targetX - deckRect.left}px, ${targetY - deckRect.top}px) rotate(360deg)`;
                    if (isSidePlayer) {
                        finalTransform += ' scale(0.1)';
                    }
                    cardElement.style.transform = finalTransform;

                    cardElement.addEventListener('transitionend', () => {
                        cardElement.remove(); // Eliminar la carta animada
                        // Solo a√±adir la carta est√°tica si NO es un jugador lateral
                        if (!isSidePlayer) {
                            const finalCard = createCardElement(deal.card);
                            finalCard.style.position = 'absolute';
                            targetHandElement.appendChild(finalCard);
                            applyFanEffect(); // Re-aplicar el abanico para un efecto progresivo
                        }
                        resolve();
                    }, { once: true });
                }, 50);
            });
        }

        function applyFanEffect() {
            const hands = document.querySelectorAll('.player-cards-hand, #dealerCards');

            hands.forEach(hand => {
                hand.style.position = 'relative';

                const cards = hand.querySelectorAll('.card');
                const total = cards.length;
                if (total === 0) return;

                const maxAngle = 20; // √Ångulo m√°ximo de rotaci√≥n
                const horizontalSpread = window.innerWidth < 568 ? 20 : 30; // Separaci√≥n de cartas responsive
                const totalWidth = (total - 1) * horizontalSpread;

                cards.forEach((card, index) => {
                    const pivotIndex = (total - 1) / 2;
                    let angle = 0;
                    if (total > 1 && pivotIndex > 0) {
                        angle = (index - pivotIndex) * (maxAngle / pivotIndex);
                    }
                    const horizontalOffset = (index * horizontalSpread) - (totalWidth / 2);

                    card.style.left = '50%';
                    card.style.transform = `translateX(calc(-50% + ${horizontalOffset}px)) rotate(${angle}deg)`;
                });
            });
        }

        // === FUNCIONES DE APUESTA ===

        function updateBetDisplay() {
            balanceEl.textContent = `${currentBalance}`;
            totalBetEl.textContent = `${currentBet}`;
        }

        function updateBettingControls() {
            if (betConfirmed || gameState !== 'betting') {
                bettingArea.classList.add('betting-controls-disabled');
            } else {
                bettingArea.classList.remove('betting-controls-disabled');
            }
        }

        function placeBet(amount) {
            if (betConfirmed || gameState !== 'betting') {
                alert('No se pueden hacer apuestas en este momento');
                return;
            }

            const newBet = currentBet + amount;
            if (newBet > currentBalance) {
                alert("No tienes suficiente saldo para esa apuesta.");
                return;
            }

            currentBet = newBet;
            updateBetDisplay();
            window.socket.emit('playerBet', { bet: currentBet });
        }

        function clearBet() {
            if (betConfirmed) return;
            // Usar el evento espec√≠fico del servidor para cancelar la apuesta.
            window.socket.emit('cancelBet');
        }

        function confirmBet() {
            if (currentBet === 0) {
                alert("Debes realizar una apuesta antes de confirmar.");
                return;
            }

            if (betConfirmed) {
                alert("Ya confirmaste tu apuesta.");
                return;
            }

            // Confirmar en el servidor
            window.socket.emit('playerConfirmBet');
            console.log(`Confirmando apuesta de ${currentBet}`);

            // Ocultar el modal inmediatamente para este jugador
            bettingArea.style.display = 'none';
        }

        // === FUNCIONES DE UTILIDAD ===

        function showNotification(message, type = 'success') {
            const container = document.getElementById('notification-container');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            container.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        async function exitRoom() {
            // No se necesita confirmaci√≥n, la salida es inmediata.
            if (window.socket) {
                // Desconectar el socket. El evento 'disconnect' en el servidor se encargar√° de la limpieza.
                window.socket.disconnect();
            }
            // Redirigir inmediatamente a la p√°gina de inicio.
            window.location.href = '/';
        }

        // Inicializar
        updateBetDisplay();
    </script>

</body>

</html>